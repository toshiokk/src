/*
 * UCON -
 * Copyright (C) 2003 Fumitoshi Ukai <ukai@debian.or.jp>
 * Copyright (C) 1999 Noritoshi Masuichi (nmasu@ma3.justnet.ne.jp)
 *
 * KON2 - Kanji ON Console -
 * Copyright (C) 1992-1996 Takashi MANABE (manabe@papilio.tutics.tut.ac.jp)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY TAKASHI MANABE ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 */

#include "ucon.h"

PRIVATE void vterm_reset_utf8_sequence(vterm_t *vterm);
PRIVATE void vterm_iso_C0_set(vterm_t *vterm, u_char ch);
PRIVATE void vterm_put_utf8_char(vterm_t *vterm, u_char ch);
PRIVATE void vterm_put_ucs2_char(vterm_t *vterm, u_short ucs2);
PRIVATE void insert_n_columns_in_insert_mode(vterm_t *vterm, int columns);
PRIVATE void vterm_wrap_pen_pos(vterm_t *vterm, int width);

PRIVATE void vterm_parse_func_esc(vterm_t *vterm, u_char ch);
PRIVATE void vterm_parse_func_csi(vterm_t*, u_char);
PRIVATE void vterm_parse_func_status_line(vterm_t *vterm, u_char mode);

PRIVATE void vterm_set_mode(vterm_t *vterm, u_char mode, bool_t on_off);
PRIVATE int vterm_esc_set_attr(vterm_t *vterm, int num, int arg_idx);
///PRIVATE void vterm_esc_set_color_num(pen_t *pen, int color_num);
PRIVATE rgb15_t rgb15_from_color256_idx(u_char color256_idx);
PRIVATE void vterm_push_pen(vterm_t *vterm, bool_t bb);
PRIVATE void vterm_pop_pen(vterm_t *vterm, bool_t bb);
PRIVATE void vterm_set_scroll_region(vterm_t *vterm, int top_y, int bottom_y);
PRIVATE void vterm_esc_report(vterm_t *vterm, u_char mode, u_short arg);

PRIVATE void vterm_pen_move_xy(vterm_t *vterm, int xx, int yy);
PRIVATE void vterm_pen_set_xy(vterm_t *vterm, int xx, int yy);
PRIVATE int vterm_pen_get_x(vterm_t *vterm);
PRIVATE int vterm_pen_get_y(vterm_t *vterm);

PRIVATE void clear_parsed_seq(void);
PRIVATE void put_parsed_seq(u_char chr);
PRIVATE void dump_parsed_seq(void);

void vterm_init(vterm_t *vterm, int columns, int lines)
{
	vterm->top_y = 0;
	vterm->bottom_y = MAX_TERM_ROWS;
	pen_init(&(vterm->pen));
	vterm->pen_stack_ptr = 0;
	vterm->pen_sl_stack_ptr = 0;
	vterm->cursor.on = TRUE;
	vterm->cursor.xx = 0;
	vterm->cursor.yy = 0;
	vterm->cursor.mode = 0;
	vterm->cursor.blink_counter = 0;
	vterm->cursor.rev_color = 0x0f;
	vterm->cursor.shown = FALSE;
	vterm->cursor.wide = FALSE;
	vterm->scroll = 0;
	vterm->clear_fb_before_repaint = 0;
	vterm->status_line = SL_NONE;

	vterm->tab_size = 8;
	vterm->insert = FALSE;
	vterm->parse_func = NULL;

	vterm_reset_utf8_sequence(vterm);

	vterm_reinit(vterm, columns, lines);
}
PRIVATE void vterm_reset_utf8_sequence(vterm_t *vterm)
{
	vterm->utf8_state = 0;
	vterm->ucs2 = 0x0000;
}
void vterm_reinit(vterm_t *vterm, int columns, int lines)
{
	columns = MIN_(MAX_TERM_COLS, columns);
	lines = MIN_(MAX_TERM_ROWS, lines);
	vterm->text_columns = columns;
	vterm->text_lines = lines;
flf_d_printf("vterm->text_lines:%2d, vterm->text_columns:%2d\n", vterm->text_lines, vterm->text_columns);
	vterm->text_characters = vterm->text_columns * vterm->text_lines;

	verbose_printf("columns:%d, lines:%d, characters:%d\n",
	 vterm->text_columns, vterm->text_lines, vterm->text_characters);

	vterm->top_y = 0;
	vterm->bottom_y = vterm->text_lines;

	fb_set_metrics();
_FLF_
}
void vterm_destroy(vterm_t *vterm)
{
}

/*---------------------------------------------------------------------------*/

int vterm_emulate_str_to_pos(vterm_t *vterm, int yy, int xx, char *string, int bytes)
{
	vterm_pen_set_xy(vterm, xx, yy);
	vterm_emulate_str(vterm, string, bytes);
	return 0;
}

// emulate VT-100 terminal
void vterm_emulate_str(vterm_t *vterm, const char *string, int bytes)
{
	u_char chr;

d_printf("ZZZ %d: {%s}\n", bytes, string);
///mflf_d_printf("%d: %s\n", bytes, dump_string(string, bytes));
	while (bytes-- > 0) {
		chr = *(string++);
///mflf_d_printf("%02x\n", ch);
		vterm_emulate_char(vterm, chr);
	}
}

int vterm_emulate_char(vterm_t *vterm, u_char chr)
{
	put_parsed_seq(chr);
	if (chr == '\0') {
		// nothing to do
		vterm_reset_utf8_sequence(vterm);
	} else if (vterm->parse_func) {
		vterm_reset_utf8_sequence(vterm);
		vterm->parse_func(vterm, chr);
	} else if (chr < 0x20) {
		vterm_reset_utf8_sequence(vterm);
		vterm_iso_C0_set(vterm, chr);
	} else {
		vterm_put_utf8_char(vterm, chr);
	}
	if (vterm->parse_func == NULL) {
///		clear_parsed_seq();
	}
	if (vterm->scroll > 0) {
		vterm_text_scroll_up(vterm, vterm->scroll);
	} else if (vterm->scroll < 0) {
		vterm_text_scroll_down(vterm, -(vterm->scroll));
	}
	vterm->scroll = 0;
	return 0;
}

// process ISO control chars [0x00, 0x1f]
PRIVATE void vterm_iso_C0_set(vterm_t *vterm, u_char ch)
{
	char buf[1];

	switch(ch) {
	case ISO_BEL:
		if (app__.no_bell == 0) {
			buf[0] = ch;
			if (write(1, buf, 1) <= 0) {	// redirect to original stdout
				_ERR_
			}
		}
		break;
	case ISO_BS:
		if (vterm_pen_get_x(vterm)) {
			vterm_pen_move_xy(vterm, -1, 0);
		}
		break;
	case ISO_HT:
		vterm_pen_move_xy(vterm,
		 vterm->tab_size - (vterm_pen_get_x(vterm) % vterm->tab_size),
		 0);
		if (vterm_pen_get_x(vterm) < vterm->text_columns) {
			break;
		}
		vterm_pen_move_xy(vterm, - vterm->text_columns, 0);
		/* fall into next case */
	case ISO_VT:
	case ISO_FF:
		/* fall into next case */
	case ISO_LF:
		if (vterm_pen_get_y(vterm) >= vterm->bottom_y - 1) {
			vterm->scroll++;
		} else {
			vterm_pen_move_xy(vterm, 0, +1);
		}
		break;
	case ISO_CR:
		vterm_pen_set_xy(vterm, 0, -1);
		break;
	case ISO_ESC:
		vterm->parse_func = vterm_parse_func_esc;
		break;
	case ISO_LS1:
		break;
	case ISO_LS0:
		break;
	default:
		break;
	}
}

PRIVATE void vterm_put_utf8_char(vterm_t *vterm, u_char ch)
{
	if (ch < 0x80) {					// 0x00--0x7f
		if (vterm->utf8_state) {
			/* illegal UTF-8 sequence? */
		}
		vterm->ucs2 = ch;
		// ASCII char, send ucs2
	} else if ((ch & 0xc0) == 0x80) {	// 10xxxxxx
		if (vterm->utf8_state == 0) {
			/* illegal UTF-8 sequence? */
			vterm->ucs2 = ch;
		} else {
			vterm->ucs2 = (vterm->ucs2 << 6) | (ch & 0x3f);
			vterm->utf8_state--;
			if (vterm->utf8_state > 0) {
				return;
			}
			// end of UTF-8 sequence, send ucs2
		}
	} else if ((ch & 0xe0) == 0xc0) {	// 110xxxxx 10xxxxxx
		vterm->utf8_state = 1;
		vterm->ucs2 = (ch & 0x1f);
		return;
	} else if ((ch & 0xf0) == 0xe0) {	// 1110xxxx 10xxxxxx 10xxxxxx
		vterm->utf8_state = 2;
		vterm->ucs2 = (ch & 0x0f);
		return;
	} else if ((ch & 0xf8) == 0xf0) {	// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		vterm->utf8_state = 3;
		vterm->ucs2 = (ch & 0x07);
		return;
	} else if ((ch & 0xfc) == 0xf8) {	// 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		vterm->utf8_state = 4;
		vterm->ucs2 = (ch & 0x03);
		return;
	} else if ((ch & 0xfe) == 0xfc) {	// 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		vterm->utf8_state = 5;
		vterm->ucs2 = (ch & 0x01);
		return;
	} else {							// 1111111x
		/* WARN: support UCS2 only */
		vterm->ucs2 = ch;
	}
	vterm_put_ucs2_char(vterm, vterm->ucs2);
	vterm_reset_utf8_sequence(vterm);
}

PRIVATE void vterm_put_ucs2_char(vterm_t *vterm, u_short ucs2)
{
	int width_in_pixels;
	int width;

	// get font width from font
	width_in_pixels = font_get_glyph_width(cur_font, ucs2);
	if (width_in_pixels <= cur_font->font_width)
		width = 1;
	else
		width = 2;
	vterm_wrap_pen_pos(vterm, width);
	vterm_adjust_pen_pos(vterm);
	insert_n_columns_in_insert_mode(vterm, width);
	if (width == 1) {
		vterm_put_to_buf_narrow(vterm, ucs2);
	} else {
		vterm_put_to_buf_wide(vterm, ucs2);
	}
	vterm_pen_move_xy(vterm, width, 0);
}

PRIVATE void insert_n_columns_in_insert_mode(vterm_t *vterm, int columns)
{
	if (vterm->insert) {
		vterm_insert_n_columns(vterm, columns);
	}
}

PRIVATE void vterm_wrap_pen_pos(vterm_t *vterm, int width)
{
	if (vterm_pen_get_x(vterm) + width > vterm->text_columns) {
		vterm_pen_set_xy(vterm, 0, -1);
		if (vterm_pen_get_y(vterm) >= vterm->bottom_y - 1) {	// already bottom of the screen
			vterm_text_scroll_up(vterm, 1);
		} else {
			vterm_pen_move_xy(vterm, 0, +1);
		}
	}
}

//-----------------------------------------------------------------------------
// ANSI Escape Sequence parsing fuctions
//-----------------------------------------------------------------------------

// convert C1 code (0x80--0x9f) to second byte of two byte sequence (0x40--0x5f)
#define Fe(x)	((x)-0x40)

// ESC [ arg1 ; arg2 ; arg3 ; arg4 ; arg5 ; arg6 ; arg7 ; arg8
#define MAX_CSI_ARGS	8
PRIVATE int csi_arg_idx = 0;
PRIVATE u_short csi_args[MAX_CSI_ARGS];

PRIVATE void clear_csi_args(void);
#ifdef ENABLE_DEBUG
PRIVATE void dump_csi_args(void);
#endif // ENABLE_DEBUG

// parse ESC ...
PRIVATE void vterm_parse_func_esc(vterm_t *vterm, u_char chr)
{
	vterm->parse_func = NULL;
	switch(chr) {
	case '['/*Fe(ISO_CSI)*/:	/* 5/11 [ */
		vterm->parse_func = vterm_parse_func_csi;
		clear_csi_args();
		break;
	case '$'/*ISO__MBS*/:		/* 2/4 $ */
		break;
	case '%'/*ISO_DOCS*/:		/* 2/5 % */
		break;
	case '('/*ISO_GZD4*/:		/* 2/8 ( */
		break;
	case ','/*MULE__GZD6*/:		/* 2/12 , */
		break;
	case ')'/*ISO_G1D4*/:		/* 2/9 ) */
		break;
	case '-'/*ISO_G1D6*/:		/* 2/13 - */
		break;
	case '*'/*ISO_G2D4*/:		/* 2/10 * */
		break;
	case '.'/*ISO_G2D6*/:		/* 2/14 . */
		break;
	case '+'/*ISO_G3D4*/:		/* 2/11 + */
		break;
	case '/'/*ISO_G3D6*/:		/* 2/15 / */
		break;
	case 'D'/*Fe(TERM_IND)*/: 	/* 4/4 D */
		if (vterm_pen_get_y(vterm) == vterm->bottom_y - 1) {
			vterm->scroll++;
		} else {
			vterm_pen_move_xy(vterm, 0, +1);
		}
		break;
	case 'E'/*Fe(ISO_NEL)*/:	/* 4/5 E */
		vterm_pen_set_xy(vterm, 0, -1);
		/* fall into next case */
	case 'M'/*Fe(ISO_RI)*/:		/* 4/13 M */
		if (vterm_pen_get_y(vterm) == vterm->top_y) {
			vterm->scroll--;
		} else {
			vterm_pen_move_xy(vterm, 0, -1);
		}
		break;
	case 'N'/*Fe(ISO_SS2)*/:	/* 4/14 N *//* 7bit single shift 2 */
		break;
	case 'O'/*Fe(ISO_SS3)*/:	/* 4/15 O *//* 7bit single shift 3 */
		break;

	case 'c'/*ISO_RIS*/:		/* 6/3 c */
		pen_init(&(vterm->pen));
		vterm_text_clear_all(vterm);
		vterm_repaint_all(vterm);
		break;
	case '7'/*DEC_SC*/:		/* 3/7 7 */
		vterm_push_pen(vterm, TRUE);
		break;
	case '8'/*DEC_RC*/:		/* 3/8 8 */
		vterm_pop_pen(vterm, TRUE);
		break;
	case 'n'/*ISO_LS2*/:		/* 6/14 n */
		break;
	case 'o'/*ISO_LS3*/:		/* 6/15 o */
		break;
	case '|'/*ISO_LS3R*/:		/* 7/12 | */
		break;
	case '}'/*ISO_LS2R*/:		/* 7/13 } */
		break;
	case '~'/*ISO_LS1R*/:		/* 7/14 ~ */
		break;
	default:
///		flf_d_printf("Unsupported sequence: ESC %c\n", ch);
///		dump_parsed_seq();
		break;
	}
}

// parse ESC '[' ...
PRIVATE void vterm_parse_func_csi(vterm_t *vterm, u_char ch)
{
	static int question = 0;
	u_short arg;
	int arg_idx;

	if ('0' <= ch && ch <= '9') {
		// ESC [ 9
		if (csi_arg_idx < MAX_CSI_ARGS) {
			csi_args[csi_arg_idx] = (csi_args[csi_arg_idx] * 10) + (ch - '0');
		}
	} else if (ch == ';') {
		// ESC [ 9 ;
		/* 引数は MAX_CSI_ARGS 個までサポート */
		if (csi_arg_idx < MAX_CSI_ARGS-1) {
			csi_arg_idx++;
		}
	} else {
#ifdef ENABLE_DEBUG
///
		dump_csi_args();
#endif // ENABLE_DEBUG
		vterm->parse_func = NULL;
		switch(ch) {
		case 'K':			// ESC [ {n} K
			vterm_text_clear_in_line(vterm, csi_args[0]);
			break;
		case 'J':			// ESC [ {n} J
			vterm_text_clear_in_screen(vterm, csi_args[0]);
			break;
		case 'X':			// ESC [ {n} X
			vterm_text_clear_columns(vterm, csi_args[0]);
			break;
		case 'A'/*ISO_CS_NO_CUU*/:	// ESC [ {n} A
			vterm_pen_move_xy(vterm, 0, -(csi_args[0] ? csi_args[0] : 1));
			if (vterm_pen_get_y(vterm) < vterm->top_y) {
				vterm->scroll -= vterm_pen_get_y(vterm) - vterm->top_y;
				vterm_pen_set_xy(vterm, -1, vterm->top_y);
			}
			break;
		case 'B'/*ISO_CS_NO_CUD*/:	// ESC [ {n} B
			vterm_pen_move_xy(vterm, 0, +(csi_args[0] ? csi_args[0] : 1));
			if (vterm_pen_get_y(vterm) >= vterm->bottom_y) {
				vterm->scroll += vterm_pen_get_y(vterm) - vterm->top_y;
				vterm_pen_set_xy(vterm, -1, vterm->bottom_y - 1);
			}
			break;
		case 'C'/*ISO_CS_NO_CUF*/:	// ESC [ {n} C
			vterm_pen_move_xy(vterm, +(csi_args[0] ? csi_args[0] : 1), 0);
			break;
		case 'D'/*ISO_CS_NO_CUB*/:	// ESC [ {n} D
			vterm_pen_move_xy(vterm, -(csi_args[0] ? csi_args[0] : 1), 0);
			break;
		case 'G':			// ESC [ {n} G
			vterm_pen_set_xy(vterm, csi_args[0] ? (csi_args[0] - 1) : 0, -1);
			break;
		case 'P':			// ESC [ {n} P
			vterm_delete_n_columns(vterm, csi_args[0] ? csi_args[0] : 1);
			break;
		case '@':			// ESC [ {n} @
			vterm_insert_n_columns(vterm, csi_args[0] ? csi_args[0] : 1);
			break;
		case 'L':			// ESC [ {n} L
			vterm_text_move_down(vterm, vterm_pen_get_y(vterm), vterm->bottom_y,
			 csi_args[0] ? csi_args[0]: 1);
			break;
		case 'M':			// ESC [ {n} G
			vterm_text_move_up(vterm, vterm_pen_get_y(vterm), vterm->bottom_y,
			 csi_args[0] ? csi_args[0]: 1);
			break;
		case 'H':			// ESC [ {m} ; {n} H
		case 'f':			// ESC [ {m} ; {n} f
			vterm_pen_set_xy(vterm, csi_args[1] ? (csi_args[1] - 1) : 0, -1);
			/* fall through to the next case */
		case 'd':
			// ESC [ {n} d
			vterm_pen_set_xy(vterm, -1, csi_args[0] ? (csi_args[0] - 1) : 0);
			/* WARN: resize(1) specify large x,y */
////		dump_parsed_seq();
			break;
		case 'm':			// ESC [ {arg1} ; {arg2} ; ... ; {arg9} m
			for (arg_idx = 0; arg_idx <= csi_arg_idx; arg_idx++) {
				arg_idx = vterm_esc_set_attr(vterm, csi_args[arg_idx], arg_idx);
			}
			break;
		case 'r':			// ESC [ {n} r
			arg = csi_args[1];
			if (arg == 0)
			    arg = vterm->text_lines;
			if (vterm->status_line != SL_NONE) {
				if (arg == vterm->text_lines) {
					 arg--;
				}
			}
			vterm_set_scroll_region(vterm, csi_args[0] ? (csi_args[0] - 1) : 0, arg);
			break;
		case 'l':			// ESC [ {n} l
			for (arg_idx = 0; arg_idx <= csi_arg_idx; arg_idx++) {
				vterm_set_mode(vterm, csi_args[arg_idx], FALSE);
			}
			break;
		case 'h':			// ESC [ {n} h
			for (arg_idx = 0; arg_idx <= csi_arg_idx; arg_idx++) {
				vterm_set_mode(vterm, csi_args[arg_idx], TRUE);
			}
			break;
		case '?':			// ESC [ {n} ?
			vterm->parse_func = vterm_parse_func_status_line;
#if 0
			question = TRUE;
			vterm->parse_func = vterm_parse_func_csi;
#endif
			break;
		case 's':			// ESC [ {n} s
			vterm_push_pen(vterm, TRUE);
			break;
		case 'u':			// ESC [ {n} u
			vterm_pop_pen(vterm, TRUE);
			break;
		case 'n':			// ESC [ {n} n
		case 'c':			// ESC [ {n} c
			if (question != TRUE) {
				vterm_esc_report(vterm, ch, csi_args[0]);
			}
			break;
		case 'R':			// ESC [ {n} R
			break;
		default:
			vterm->parse_func = vterm_parse_func_csi;
			warn_printf("Unsupported sequence: ESC [ n %c\n", ch);
			dump_parsed_seq();
			break;
		}
		if (vterm->parse_func == NULL) {
			clear_csi_args();
		}
	}
}

// parse ESC [ ? ...
PRIVATE void vterm_parse_func_status_line(vterm_t *vterm, u_char mode)
{
	switch(mode) {
	case 'T':	/* To */
		if (vterm->status_line == SL_ENTER)
			break;
///		if (vterm->saved_pen_sl == 0) {
			vterm_push_pen(vterm, FALSE);
///		}
	case 'S':	/* Show */
		if (vterm->status_line == SL_NONE) {
			vterm->bottom_y = vterm->text_lines - 1;
			vterm_set_window_size(vterm);
		}
		if (mode == 'T') {
			vterm->status_line = SL_ENTER;
			vterm_set_scroll_region(vterm, vterm->text_lines - 1, vterm->text_lines);
		}
		break;
	case 'F':	/* From */
		if (vterm->status_line == SL_ENTER) {
			vterm->status_line = SL_LEAVE;
			vterm_set_scroll_region(vterm, 0, vterm->text_lines - 1);
///			if (vterm->saved_pen_sl) {
				vterm_pop_pen(vterm, FALSE);
///			}
///			vterm->saved_pen_sl = NULL;
		}
		break;
	case 'H':	/* Hide */
	case 'E':	/* Erase */
		if (vterm->status_line == SL_NONE) {
			break;
		}
		vterm_set_scroll_region(vterm, 0, vterm->text_lines);
		vterm_set_window_size(vterm);
		vterm->status_line = SL_NONE;
		break;
	default:
		vterm->parse_func = vterm_parse_func_csi;
		vterm_parse_func_csi(vterm, mode);
		return;
	}
	vterm->parse_func = NULL;
}

/*---------------------------------------------------------------------------*/
PRIVATE void clear_csi_args(void)
{
	for (csi_arg_idx = 0; csi_arg_idx < MAX_CSI_ARGS; csi_arg_idx++) {
		csi_args[csi_arg_idx] = 0;
	}
	csi_arg_idx = 0;
}
#ifdef ENABLE_DEBUG
PRIVATE void dump_csi_args(void)
{
	int arg_idx;

	flf_d_printf("{");
	for (arg_idx = 0; arg_idx <= csi_arg_idx; arg_idx++) {
		d_printf(" %d", csi_args[arg_idx]);
	}
	d_printf(" }\n");
}
#endif // ENABLE_DEBUG

PRIVATE void vterm_set_mode(vterm_t *vterm, u_char mode, bool_t on_off)
{
	switch(mode) {
	case 4:
		vterm->insert = on_off;
		break;
	case 25:
		vterm_set_cursor_on_off(vterm, on_off);
		break;
	}
}

// analyze p1, p2, p3, ... in ESC [ p1 ; p2 ; p3 ... m
PRIVATE int vterm_esc_set_attr(vterm_t *vterm, int num, int arg_idx)
{
	c_idx_t color_idx;

	switch(num) {
	case 0:
		pen_off_all_attr(&(vterm->pen));
		break;

	case 1:
		pen_highlight(&(vterm->pen));
		break;
	case 21:
		pen_unhighlight(&(vterm->pen));
		break;

	case 2:		// dim
		break;
	case 22:	// not dim
		break;

	case 3:		// italic
		break;
	case 23:	// not italic
		break;

	case 4:
		pen_underline(&(vterm->pen));
		break;
	case 24:
		pen_no_underline(&(vterm->pen));
		break;

	case 5:		// blink (slow)
		break;
	case 25:	// not blink
		break;

	case 6:		// blink (fast)
		break;
	case 26:	// not blink
		break;

	case 7:
		pen_reverse(&(vterm->pen));
		break;
	case 27:
		pen_no_reverse(&(vterm->pen));
		break;

	case 10:	/* primary font */
		break;
	case 11:	/* alternative font */
	case 12:
	case 13:
	case 14:
	case 15:
	case 16:
	case 17:
	case 18:
	case 19:
		break;

	case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
	case 39:
	case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:
	case 49:
	case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:
	case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:
		if (30 <= num && num <= 37) {
			color_idx = num - 30;				// normal fg color [0, 7]
		} else if (num <= 39) {
			color_idx = COLOR_DEF_FG;
		} else if (40 <= num && num <= 47) {
			color_idx = num - 40;				// normal bg color [0, 7]
		} else if (num <= 49) {
			color_idx = COLOR_DEF_BG;
		} else if (90 <= num && num <= 97) {
			color_idx = (num - 90) | COLOR_HIGHLIGHT;		// bright fg color [8, 15]
		} else if (100 <= num && num <= 107) {
			color_idx = (num - 100) | COLOR_HIGHLIGHT;		// bright bg color [8, 15]
		}
		if ((30 <= num && num <= 37)
		 || (num <= 39)
		 || (90 <= num && num <= 97)) {
			pen_set_fg_color_idx(&(vterm->pen), color_idx);
		} else if ((40 <= num && num <= 47)
		 || (num <= 49)
		 || (100 <= num && num <= 107)) {
			pen_set_bg_color_idx(&(vterm->pen), color_idx);
		}
		break;
	case 38:
	case 48:
		if (MAX_CSI_ARGS - arg_idx >= 3) {
			if (csi_args[arg_idx+1] == 5) {
				if (num == 38) {
					// ESC [ 38 ; 5 ; {color_idx} m
					pen_set_fc_rgb_direct(&(vterm->pen), rgb15_from_color256_idx(csi_args[arg_idx+2]));
				} else {
					// ESC [ 48 ; 5 ; {color_idx} m
					pen_set_bc_rgb_direct(&(vterm->pen), rgb15_from_color256_idx(csi_args[arg_idx+2]));
				}
				arg_idx += 3;	// eat 3 arguments
			}
		}
		if (MAX_CSI_ARGS - arg_idx >= 5) {
			if (csi_args[arg_idx+1] == 2) {
				if (num == 38) {
					// ESC [ 38 ; 2 ; {red} ; {green} ; {blue} m
					pen_set_fc_rgb_direct(&(vterm->pen),
					 rgb15_from_r_g_b_24(csi_args[arg_idx+2], csi_args[arg_idx+3], csi_args[arg_idx+4]));
				} else {
					// ESC [ 48 ; 2 ; {red} ; {green} ; {blue} m
					pen_set_bc_rgb_direct(&(vterm->pen),
					 rgb15_from_r_g_b_24(csi_args[arg_idx+2], csi_args[arg_idx+3], csi_args[arg_idx+4]));
				}
				arg_idx += 5;	// eat 5 arguments
			}
		}
		break;
	default:
///		vterm_esc_set_color_num(&(vterm->pen), num);
		break;
	}
	return arg_idx;
}

///PRIVATE void vterm_esc_set_color_num(pen_t *pen, int color_num)
///{
///}

PRIVATE rgb15_t rgb15_from_color256_idx(u_char color256_idx)
{
	int color_idx;
	int rr, gg, bb;

	if (color256_idx < 16) {
		// 16 ANSI colors
		color_idx = color256_idx;		// [0, 15]
		return rgb15_from_color_idx(color_idx);
	} else
	if (color256_idx < 16 + 216) {
		// 24 gray scale colors (216 = 6 * 6 * 6)
		color_idx = color256_idx - 16;	// [16, 232) ==> [0, 216)
		bb = (color_idx % 6);		// [0, 5]
		gg = ((color_idx / 6) % 6);	// [0, 5]
		rr = (color_idx / 36);		// [0, 5]
		bb *= 51;	// 0, 51, 102, 153, 204, 255
		gg *= 51;	// 0, 51, 102, 153, 204, 255
		rr *= 51;	// 0, 51, 102, 153, 204, 255
		return rgb15_from_r_g_b_24(rr, gg, bb);
	} else {
		// 24 gray scale colors
		color_idx = color256_idx - (16 + 216);	// [232, 255] ==> [0, 23]
		color_idx *= 11;						// [0, 253]
		return rgb15_from_r_g_b_24(color_idx, color_idx, color_idx);
	}
}

PRIVATE void vterm_push_pen(vterm_t *vterm, bool_t bb)
{
	if (bb) {
		if (vterm->pen_stack_ptr < PEN_STACK_DEPTH) {
			pen_copy(&vterm->pen_stack[vterm->pen_stack_ptr], &vterm->pen);
			vterm->pen_stack_ptr++;
		}
	} else {
		if (vterm->pen_sl_stack_ptr < PEN_STACK_DEPTH) {
			pen_copy(&vterm->pen_sl_stack[vterm->pen_sl_stack_ptr], &vterm->pen);
			vterm->pen_sl_stack_ptr++;
		}
	}
}
PRIVATE void vterm_pop_pen(vterm_t *vterm, bool_t bb)
{
	if (bb) {
		if (vterm->pen_stack_ptr > 0) {
			vterm->pen_stack_ptr--;
			pen_copy(&vterm->pen, &vterm->pen_stack[vterm->pen_stack_ptr]);
		}
	} else {
		if (vterm->pen_sl_stack_ptr > 0) {
			vterm->pen_sl_stack_ptr--;
			pen_copy(&vterm->pen, &vterm->pen_sl_stack[vterm->pen_sl_stack_ptr]);
		}
	}
}

PRIVATE void vterm_set_scroll_region(vterm_t *vterm, int top_y, int bottom_y)
{
	if (top_y < 0 || vterm->text_lines <= top_y
	 || bottom_y < 0 || vterm->text_lines < bottom_y
	 || top_y > bottom_y) {
		msg_printf("illegal (top:%d, bottom:%d)\n", top_y, bottom_y);
		// illegal parameter
		return;
	}
	vterm->top_y = top_y;
	vterm->bottom_y = bottom_y;
	vterm->pen.xx = 0;
	if (vterm->pen.yy < vterm->top_y) {
		// pen position is out of region, correct it
		vterm->pen.yy = vterm->top_y;
	} else if (vterm->bottom_y <= vterm->pen.yy) {
		// pen position is out of region, correct it
		vterm->pen.yy = vterm->bottom_y-1;
	}
}

PRIVATE void vterm_esc_report(vterm_t *vterm, u_char mode, u_short arg)
{
#define MAX_REPORT_LEN		100
	char report[MAX_REPORT_LEN+1];
	int xx;
	int yy;

	report[0] = '\0';
	switch(mode) {
	case 'n':
		switch(arg) {
		case 5:
			// send "device OK"
			strcpy(report, "\x1B[0n\0");
			break;
		case 6:
			// send "current cursor position"
///			int xx = (vterm->pen.xx < vterm->text_columns - 1)
///			 ? vterm->pen.xx : vterm->text_columns - 1;
///			int yy = (vterm->pen.yy < vterm->bottom_y - 1)
///			 ? vterm->pen.yy : vterm->bottom_y - 1;
			xx = vterm->pen.xx;
			yy = vterm->pen.yy;
			snprintf(report, MAX_REPORT_LEN+1, "\x1b[%d;%dR", yy+1, xx+1);
			break;
		}
		break;
	case 'c':
#if 0
		if (arg == 0) {
			snprintf(report, MAX_REPORT_LEN+1, "\x1b[%s0c", PACKAGE);
		}
#endif
		break;
	}
	if (write(term__.fd_pty_master, report, strlen(report)) < 0) {
		_ERR_
	}
}

//-----------------------------------------------------------------------------

PRIVATE void vterm_pen_move_xy(vterm_t *vterm, int xx, int yy)
{
	pen_move_xy(&vterm->pen, xx, yy);
}
PRIVATE void vterm_pen_set_xy(vterm_t *vterm, int xx, int yy)
{
	pen_set_xy(&vterm->pen, xx, yy);
	vterm_adjust_pen_pos(vterm);
}

PRIVATE int vterm_pen_get_x(vterm_t *vterm)
{
	return pen_get_x(&vterm->pen);
}
PRIVATE int vterm_pen_get_y(vterm_t *vterm)
{
	return pen_get_y(&vterm->pen);
}

//-----------------------------------------------------------------------------

#define MAX_SEQ		20
PRIVATE int parsed_seq_idx = 0;
PRIVATE u_char parsed_seq[MAX_SEQ+1];
PRIVATE void clear_parsed_seq(void)
{
	parsed_seq_idx = 0;
	parsed_seq[parsed_seq_idx] = '\0';
}
PRIVATE void put_parsed_seq(u_char chr)
{
	if (parsed_seq_idx < MAX_SEQ) {
		parsed_seq[parsed_seq_idx] = chr;
		parsed_seq_idx++;
	} else {
		strcpy_ol(parsed_seq, &parsed_seq[1]);
		parsed_seq[parsed_seq_idx-1] = chr;
	}
	parsed_seq[parsed_seq_idx] = '\0';
}
PRIVATE void dump_parsed_seq(void)
{
	int seq_idx;

	flf_d_printf("{");
	for (seq_idx = 0; seq_idx < parsed_seq_idx; seq_idx++) {
		if (isprint(parsed_seq[seq_idx])) {
			d_printf("%c ", parsed_seq[seq_idx]);
		} else {
			d_printf("%02x ", parsed_seq[seq_idx]);
		}
	}
	d_printf("}\n");
	clear_parsed_seq();
}

// End of vterm.c
