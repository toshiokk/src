//
// Simple Japanese Input Method implementation
//

// [Input Method layer description]
// ui: User Interface
//   keyboard and mouse input.
//   display output.
//   send KANJI to application
// atoh: ASCII to HIRAGANA(YOMI/Pronunciation) conversion(ROMA-JI-HENKAN)
//   inputing and editing of YOMI and converting between hankaku/zenkaku
// htok: HIRAGANA to KANJI conversion management
//   separating YOMI into BUNSETSU(sentences)
//   converting BUSETSU to KANJI using dictionary
//   selecting one candidate from several candidates gotten from dictionary
// dic: HIRAGANA/KANJI conversion using dictionary file
//   convertiong from YOMI to KANJI
//     searching in dictionary of YOMI and getting candidates of KANJI
//

// atoj (ASCII to Japanese)
// atoh (ASCII to Hiragana)
// htok (Hiragana to Kanji)
// htoa (Hiragana to ASCII)

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>

#include "imj.h"

//#define	ROM_FILE_NAME		"atok.rom"
#define	DIC_FILE_NAME		"imj.dic"
#define	CNVHST_FILE_NAME	"imj.hst"
#define	MAX_DIC_LINE_LEN	4096
#define	MAX_DIC_RECORDS		1000000
#define	MAX_CANNA_HINSHI_CODE_LEN	(1+10+1+3)		// "#ABCDEFGHIJ*500"

// Unvisible separator
#ifdef DEBUG
#define	IM_UNVIS_SEP			'|'
#else
#define	IM_UNVIS_SEP			'\x1f'
#endif // DEBUG

PRIVATE int im_i_start(void);
PRIVATE int im_i_abort(void);
PRIVATE int im_i_backspace(void);
PRIVATE int im_i_delete(void);
PRIVATE int im_i_input_romaji(int chr);

PRIVATE int im_i_select_prev(void);
PRIVATE int im_i_select_next(void);
PRIVATE int im_i_select_first(void);
PRIVATE int im_i_select_last(void);

PRIVATE int im_i_cursor_left(void);
PRIVATE int im_i_cursor_right(void);
PRIVATE int im_i_hiragana(void);
PRIVATE int im_i_katakana(void);
PRIVATE int im_i_hankaku_katakana(void);
PRIVATE int im_i_zenkaku_alnum(void);
PRIVATE int im_i_hankaku_alnum(void);
PRIVATE int im_i_commit_all(void);

PRIVATE int im_c_start_conversion(void);
PRIVATE int im_c_end_conversion(void);
PRIVATE int im_c_abort_conversion(void);
PRIVATE int im_c_select_prev(void);
PRIVATE int im_c_select_next(void);
PRIVATE int im_c_select_prev_page(void);
PRIVATE int im_c_select_next_page(void);
PRIVATE int im_c_select_first(void);
PRIVATE int im_c_select_last(void);
PRIVATE int im_c_commit_all(void);
PRIVATE int im_c_commit_one(void);
PRIVATE int im_c_hiragana(void);
PRIVATE int im_c_katakana(void);
PRIVATE int im_c_hankaku(void);
PRIVATE int im_c_zenkaku_alnum(void);
PRIVATE int im_c_hankaku_alnum(void);
PRIVATE int im_c_left_separation(void);
PRIVATE int im_c_right_separation(void);
PRIVATE int im_c_search_dic(void);
PRIVATE int im_c_get_cur_candid(void);
PRIVATE int im_i_commit_string(char *string);

#define	MAX_CANDIDS_LIST		300
struct _candidate_ {
	int pronun_len;
	char candidate[MAX_CANDID_LEN+1];
};
typedef struct _candidate_ candidates_t[MAX_CANDIDS_LIST];
PRIVATE int imjdichst_search(char *pronun, int len_to_match);
PRIVATE int imjdichst_merge_dic_hst_candids(char *pronun, int len_to_match);
//-----------------------------------------------------------------------------

PRIVATE int imjihst_get_histories(void);
PRIVATE int imjihst_get_nth_history(int hist_idx, char *history, int buf_len);
PRIVATE int imjihst_insert_newest(const char *pronun);

PRIVATE int imjchst_get_matches(char *pronun, int len_to_match);
PRIVATE int imjchst_get_nth_match(int match_idx, char *pronun, int len_to_match,
 char *conversion, int buf_len);
PRIVATE int imjchst_search_longest_match(char *pronun);
PRIVATE int imjchst_insert_newest(const char *pronun, const char *conversion);

PRIVATE int imjhst_clear_all(void);
PRIVATE int imjhst_get_entries(void);
PRIVATE int imjhst_is_updated(void);
PRIVATE int imjhst_set_updated(void);
PRIVATE int imjhst_clear_updated(void);
PRIVATE int imjhst_append_entry(char *pronun, char *conversion);
PRIVATE int imjhst_insert_newest(const char *pronun, const char *conversion);
PRIVATE void imjhst_shift_older(void);
PRIVATE int imjhst_delete_entry(int entry_idx);
PRIVATE int imjhst_is_there_the_same_entry(int start_entry_idx,
 const char *pronun, const char *conversion);
PRIVATE int imjhst_search_exact_match(int start_entry_idx,
 const char *pronun, int len_to_match, const char *conversion);
PRIVATE int imjhst_get_entry(int entry_idx, char *pronun, char *conversion);
PRIVATE int imjhst_put_entry(int entry_idx, const char *pronun, const char *conversion);

#define	MAX_CONVERSION_HISTORIES	1000	//  1 2 3 4 5 6 7 8 9 0 1 2 3 4
///#define	MAX_CONVERSION_HISTORIES	10000	//  1 2 3 4 5 6 7 8 9 0 1 2 3 4
#define	MAX_HISTORY_PRONUN_LEN		(MAX_UTF8C_BYTES*MAX_DIC_PRONUN_CHARS)	// "えくすてんでっどえでぃしょん"
#define	MAX_HISTORY_CONVERTED_LEN	(MAX_UTF8C_BYTES*MAX_DIC_PRONUN_CHARS)	// "エクステンデッドエディション"
#define	MAX_HISTORY_LINE_LEN	\
 (MAX_HISTORY_PRONUN_LEN+1+MAX_HISTORY_CONVERTED_LEN+1+1)	// "よみ 読み" + "\n\0"

#define	MAX_PATH_LEN	256
char imjhst_file_path[MAX_PATH_LEN+1] = "";
//-----------------------------------------------------------------------------

PRIVATE int imjcandid_clear_candids(void);
PRIVATE int imjcandid_get_num_of_candids(void);
PRIVATE int imjcandid_append_one_candid(char *candid);
PRIVATE int imjcandid_insert_one_candid(char *candid);
PRIVATE int imjcandid_is_there_the_same_candid(char *candid);
PRIVATE int imjcandid_delete_one_candid(int candid_idx);
PRIVATE int imjcandid_compare_candid(int candid_idx, char *candid);
PRIVATE int imjcandid_put_candid(int candid_idx, char *candid, int len);
PRIVATE int imjcandid_get_candid(int candid_idx, char *buf, int buf_len);
PRIVATE int imjcandid_dump_candids(void);

PRIVATE int imjhira_conv_hira_kata_han(const char *str, char *buf, int buf_len,
 const char *table_from, const char *table_to);

static int im_mode = IM_UI_MODE_OFF;
static int im_candids_per_page = CANDIDS_PER_PAGE;
static char im_i_romaji[IM_INPUT_LINE_LEN+1] = "";	// ROMAJI input
static char im_i_pronun[IM_INPUT_LINE_LEN+1] = "";	// pronunciation (YOMI)
static int im_i_cursor_offset = 0;					// cursor position on pronunciation

static int im_i_cur_history_idx = -1;				// history index currently selected
static int im_i_num_of_histories;					// number of available histories

static int im_c_len_to_match = 0;					// length of pronunciation currently being converted
static int im_c_cur_candid_idx = 0;					// index currently selected
static int im_c_num_of_candids = 0;					// number of available candidates
static char im_c_cur_candid[MAX_CANDID_LEN+1] = "";
									// buffer in which selected candidate is temporarily placed
static char im_i_commit_buf[IM_INPUT_LINE_LEN+1] = "";	// buffer in which committed string is held

int im_open(char *dir)
{
	char buf[MAX_PATH_LEN+1];
	char buffer[MAX_PATH_LEN+1];
	char *dic_path = NULL;
	char *hst_path = NULL;
	int ret = 0;

_FLF_
	if (dir) {
		strlcpy(buf, dir, MAX_PATH_LEN);
		strlcat(buf, "/.imj/", MAX_PATH_LEN);	// "/home/user/.imj/"
		dir = buf;
	}

	if (dir) {
		strcpy(buffer, dir);
		strlcat(buffer, DIC_FILE_NAME, MAX_PATH_LEN);
		dic_path = buffer;
	}
	if (imjdic_open(dic_path)) {
		ret = (ret == 0) ? 1 : ret;
	}

	if (dir) {
		strcpy(buffer, dir);
		strlcat(buffer, CNVHST_FILE_NAME, MAX_PATH_LEN);
		hst_path = buffer;
	}
	if (imjhst_load(hst_path)) {
		ret = (ret == 0) ? 2 : ret;
	}

//	ret |= atoh_load_table(NULL);

///	test_hira_kata_han_conversion();
///	imj_test_expand_katsuyou();
	return ret;
}
int im_close(void)
{
	int ret = 0;

_FLF_
	ret |= imjhst_save_if_updated(NULL);
	ret |= imjdic_close();
	return ret;
}

int im_process_key(int key)
{
	return im_process_key_event(key, key);
}
int im_process_key_event(int key, int event)
{
	int key_eaten = 1;

//flf_d_printf("key:%04x, event:%04x\n", key, event);
	switch(im_get_mode()) {
	case IM_UI_MODE_OFF:
		if (event == IM_KE_ON) {
			im_set_mode(IM_UI_MODE_INPUT);
			key = -1;
		}
		break;
	case IM_UI_MODE_INPUT:
	case IM_UI_MODE_CONVERSION:
		if (event == IM_KE_ON || event == IM_KE_OFF) {
			im_set_mode(IM_UI_MODE_OFF);
			key = -1;
		}
		break;
	}
	switch(im_mode) {
	case IM_UI_MODE_OFF:
		key_eaten = 0;
		break;
	case IM_UI_MODE_INPUT:
		if (strlen(im_i_pronun) == 0) {
			if (isprint(key) == 0) {
				key_eaten = 0;
				break;
			} else if (key == ' ') {
				if (im_i_input_romaji(key) < 0)
					break;
			}
		}
		switch(event) {
		case IM_KE_ABORT_INPUT:
			im_i_abort();
			break;
		case IM_KE_COMMIT_ALL:
			im_i_commit_all();
			break;
		case IM_KE_SELECT_PREV:
		case IM_KE_SELECT_NEXT:
		case IM_KE_SELECT_FIRST:
		case IM_KE_SELECT_LAST:
			if (strlen(im_i_pronun) == 0) {
				key_eaten = 0;
				break;
			}
			switch(event) {
			default:
			case IM_KE_SELECT_PREV:
_FLF_
				im_i_select_prev();
				break;
			case IM_KE_SELECT_NEXT:
_FLF_
				im_i_select_next();
				break;
			case IM_KE_SELECT_FIRST:
				im_i_select_first();
				break;
			case IM_KE_SELECT_LAST:
				im_i_select_last();
				break;
			}
			break;
		case IM_KE_CONVERT:
			im_c_start_conversion();
			break;
		case IM_KE_CURSOR_LEFT:
			im_i_cursor_left();
			break;
		case IM_KE_CURSOR_RIGHT:
			im_i_cursor_right();
			break;
		case IM_KE_HIRAGANA:
			im_i_hiragana();
			break;
		case IM_KE_KATAKANA:
			im_i_katakana();
			break;
		case IM_KE_HANKAKU_KATAKANA:
			im_i_hankaku_katakana();
			break;
		case IM_KE_ZENKAKU_ALNUM:
			im_i_zenkaku_alnum();
			break;
		case IM_KE_HANKAKU_ALNUM:
			im_i_hankaku_alnum();
			break;
		case IM_KE_CLEAR:
			im_i_abort();
			break;
		case IM_KE_BACKSPACE:
			im_i_backspace();
			break;
		case IM_KE_DELETE:
			im_i_delete();
			break;
		default:
			if (im_i_input_romaji(key) >= 0)
				key_eaten = 0;
			break;
		}
		break;
	case IM_UI_MODE_CONVERSION:
		switch(event) {
		case IM_KE_ABORT_CONVERSION:
			im_c_abort_conversion();
			im_i_abort();
			break;
		case IM_KE_SELECT_PREV:
			im_c_select_prev();
			break;
		case IM_KE_CONVERT:
		case IM_KE_SELECT_NEXT:
			im_c_select_next();
			break;
		case IM_KE_SELECT_PREV_PAGE:
			im_c_select_prev_page();
			break;
		case IM_KE_SELECT_NEXT_PAGE:
			im_c_select_next_page();
			break;
		case IM_KE_SELECT_FIRST:
			im_c_select_first();
			break;
		case IM_KE_SELECT_LAST:
			im_c_select_last();
			break;
		case IM_KE_BACKSPACE:
			im_set_mode(IM_UI_MODE_INPUT);
			break;
		case IM_KE_COMMIT_ONE:
			im_c_commit_one();
			break;
		case IM_KE_COMMIT_ALL:
			im_c_commit_all();
			break;
		case IM_KE_HIRAGANA:
			im_c_hiragana();
			break;
		case IM_KE_KATAKANA:
			im_c_katakana();
			break;
		case IM_KE_HANKAKU_KATAKANA:
			im_c_hankaku();
			break;
		case IM_KE_ZENKAKU_ALNUM:
			im_c_zenkaku_alnum();
			break;
		case IM_KE_HANKAKU_ALNUM:
			im_c_hankaku_alnum();
			break;
		case IM_KE_SEPARATION_LEFT:
			im_c_left_separation();
			break;
		case IM_KE_SEPARATION_RIGHT:
			im_c_right_separation();
			break;
		default:
			if (isgraph(key)) {
				im_c_commit_all();
				if (im_i_input_romaji(key) >= 0)
					key_eaten = 0;
			}
			break;
		}
		if (strlen(im_i_pronun) == 0)
			im_c_end_conversion();
		break;
	}
//_FLF_
	if (key_eaten)
		key = -1;
//flf_d_printf("=>key:%04x\n", key);
	return key;
}
int im_set_candids_per_page(int candids)
{
	return im_candids_per_page = candids;
}
int im_get_candids_per_page(void)
{
	return im_candids_per_page;
}
int im_set_mode(int __im_mode)
{
	im_mode = __im_mode;
	switch(im_mode) {
	case IM_UI_MODE_OFF:
		break;
	case IM_UI_MODE_INPUT:
		im_c_num_of_candids = 0;
		im_c_cur_candid_idx = 0;
		im_c_cur_candid[0] = '\0';
//im_i_commit_buf[0] = '\0';
		break;
	case IM_UI_MODE_CONVERSION:
		break;
	}
	return im_mode;
}
int im_get_mode(void)
{
	return im_mode;
}
int im_set_romaji(char *string)
{
	utf8strlcpy(im_i_romaji, IM_INPUT_LINE_LEN, string);
	atoh_convert_line(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
	im_c_start_conversion();
	return 0;
}
int im_get_pronun(char *buf, int buf_len)
{
	utf8strlcpy(buf, buf_len, im_i_pronun);
	return im_get_pronun_len();
}
int im_get_pronun_len(void)
{
	return strlen(im_i_pronun);
}
int im_get_pronun_len_to_match(void)
{
	return im_c_len_to_match;
}
int im_get_cursor_offset()
{
	return im_i_cursor_offset;
}
//-----------------------------------------------------------------------------
int im_i_clear_cur_history_idx(void)
{
	im_i_cur_history_idx = -1;
	return 0;
}
int im_i_get_cur_history_idx(void)
{
	return im_i_cur_history_idx;
}
int im_i_get_num_of_histories(void)
{
	if (im_i_cur_history_idx < 0) {
		im_i_cur_history_idx = 0;
		im_i_num_of_histories = imjihst_get_histories();
	}
	return im_i_num_of_histories;
}
int im_i_check_set_history_idx(int hist_idx)
{
	if (hist_idx < 0)
		hist_idx = im_i_get_num_of_histories()-1;
	if (hist_idx >= im_i_get_num_of_histories())
		hist_idx = 0;
	im_i_set_cur_history_idx(hist_idx);
	return 0;
}
int im_i_set_cur_history_idx(int hist_idx)
{
	im_i_cur_history_idx = hist_idx;
	im_i_get_cur_history();
	return 0;
}
int im_i_get_cur_history(void)
{
	imjihst_get_nth_history(im_i_cur_history_idx, im_i_pronun, IM_INPUT_LINE_LEN);
	im_i_cursor_offset = strlen(im_i_pronun);
	return 0;
}
//-----------------------------------------------------------------------------
int im_c_get_cur_candid_buf(char *buf, int buf_len)
{
	utf8strlcpy(buf, buf_len, im_c_cur_candid);
	return 0;
}
int im_c_get_one_candid(int candid_idx, char *buf, int buf_len)
{
	return imjcandid_get_candid(candid_idx, buf, buf_len);
}
int im_c_get_num_of_candids(void)
{
	return im_c_num_of_candids;
}
int im_c_check_set_candid_idx(int candid_idx)
{
	if (candid_idx < 0)
		candid_idx = im_c_get_num_of_candids()-1;
	if (candid_idx >= im_c_get_num_of_candids())
		candid_idx = 0;
	im_c_set_cur_candid_idx(candid_idx);
	return 0;
}
int im_c_set_cur_candid_idx(int candid_idx)
{
	im_c_cur_candid_idx = candid_idx;
	im_c_get_cur_candid();
	return 0;
}
int im_c_get_cur_candid_idx(void)
{
	return im_c_cur_candid_idx;
}

int im_get_committed_string(char *buf, int buf_len)
{
	utf8strlcpy(buf, buf_len, im_i_commit_buf);
	im_i_commit_buf[0] = '\0';	// clear
	return strlen(buf);
}

//-----------------------------------------------------------------------------

// im_i_: Input-Method Input processing

PRIVATE int im_i_start(void)
{
	return im_i_input_romaji(IM_KE_CLEAR);
}
PRIVATE int im_i_abort(void)
{
	return im_i_input_romaji(IM_KE_CLEAR);
}
PRIVATE int im_i_backspace(void)
{
	return im_i_input_romaji(IM_KE_BACKSPACE);
}
PRIVATE int im_i_delete(void)
{
	return im_i_input_romaji(IM_KE_DELETE);
}

PRIVATE int im_i_input_romaji(int chr)
{
	char insert[2+1];
	int off_from;
	int off_to;
	int offset_r;
	int key_eaten = 1;

	im_i_clear_cur_history_idx();
	if (chr == IM_KE_CLEAR) {				// Ctrl-L
		im_i_romaji[0] = '\0';
		im_i_cursor_offset = strlen(im_i_pronun);
	} else if (chr == IM_KE_DELETE) {		// Ctrl-G
		off_from = im_i_cursor_offset;
		off_to = utf8s_len_ge(im_i_pronun, im_i_cursor_offset+1);
		atoh_delete_pronun_chars(im_i_romaji, IM_INPUT_LINE_LEN,
		 im_i_pronun, off_from, off_to);
flf_d_printf("[%s][%s]\n", im_i_romaji, im_i_pronun);
	} else if (chr == IM_KE_BACKSPACE) {	// Ctrl-H
		off_from = utf8s_len_le(im_i_pronun, im_i_cursor_offset-1);
		off_to = im_i_cursor_offset;
		atoh_delete_pronun_chars(im_i_romaji, IM_INPUT_LINE_LEN,
		 im_i_pronun, off_from, off_to);
flf_d_printf("[%s][%s]\n", im_i_romaji, im_i_pronun);
		im_i_cursor_offset = off_from;
	} else if (chr < 0x0100) {
//		if (strlen(im_i_pronun) == 0 && chr <= ' ') {
//			im_i_pronun[0] = chr;
//			im_i_pronun[1] = '\0';
//			im_i_commit_string(im_i_pronun);
//			im_i_start();
//		} else 
		if (isprint(chr)) {
flf_d_printf("add[%02x]\n", chr);
			if (im_i_pronun[im_i_cursor_offset] == '\0') {
				insert[0] = chr;
				insert[1] = '\0';
			} else {
				insert[0] = chr;
				insert[1] = IM_UNVIS_SEP;
				insert[2] = '\0';
			}
			atoh_insert_romaji_chars(im_i_romaji, IM_INPUT_LINE_LEN,
			 im_i_pronun, im_i_cursor_offset, insert);
			atoh_convert_line(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
			offset_r = atoh_romaji_offset(im_i_romaji, im_i_cursor_offset) + strlen(insert);
			im_i_cursor_offset = atoh_hira_offset(im_i_romaji, im_i_pronun, offset_r);
			return -1;
		} else {
			key_eaten = 0;
		}
	} else {
		key_eaten = 0;
	}
	if (key_eaten == 0)
		return chr;
	atoh_convert_line(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
	return -1;		// key eaten
}

PRIVATE int im_i_select_prev(void)
{
	im_i_check_set_history_idx(im_i_get_cur_history_idx()+1);
	return 0;
}
PRIVATE int im_i_select_next(void)
{
	im_i_check_set_history_idx(im_i_get_cur_history_idx()-1);
	return 0;
}
PRIVATE int im_i_select_first(void)
{
	im_i_set_cur_history_idx(0);
	return 0;
}
PRIVATE int im_i_select_last(void)
{
	im_i_set_cur_history_idx(im_i_get_num_of_histories()-1);
	return 0;
}

PRIVATE int im_i_cursor_left(void)
{
	im_i_cursor_offset = utf8s_len_le(im_i_pronun, im_i_cursor_offset-1);
	return 0;
}
PRIVATE int im_i_cursor_right(void)
{
	im_i_cursor_offset = utf8s_len_ge(im_i_pronun, im_i_cursor_offset+1);
	return 0;
}
PRIVATE int im_i_hiragana(void)
{
	atoh_convert_line(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
	im_i_cursor_offset = strlen(im_i_pronun);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_i_katakana(void)
{
	atoh_convert_line(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
	imjhira_to_kata(im_i_pronun, im_i_pronun, IM_INPUT_LINE_LEN);
	im_i_cursor_offset = strlen(im_i_pronun);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_i_hankaku_katakana(void)
{
	atoh_convert_line(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
	imjhira_to_han_kata(im_i_pronun, im_i_pronun, IM_INPUT_LINE_LEN);
	im_i_cursor_offset = strlen(im_i_pronun);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_i_zenkaku_alnum(void)
{
	imjhira_to_hira(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
	im_i_cursor_offset = strlen(im_i_pronun);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_i_hankaku_alnum(void)
{
	imjhira_to_han_kata(im_i_romaji, im_i_pronun, IM_INPUT_LINE_LEN);
	im_i_cursor_offset = strlen(im_i_pronun);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_i_commit_all(void)
{
_FLF_
	imjihst_insert_newest(im_i_pronun);
	im_i_commit_string(im_i_pronun);
	im_i_start();
	return 0;
}

// im_c_: Input-Method Conversion processing

PRIVATE int im_c_start_conversion(void)
{
_FLF_
	imjihst_insert_newest(im_i_pronun);
	im_set_mode(IM_UI_MODE_CONVERSION);
_FLF_
	im_c_len_to_match = 0;
_FLF_
	im_c_search_dic();
_FLF_
	return 0;
}
PRIVATE int im_c_end_conversion(void)
{
_FLF_
	im_set_mode(IM_UI_MODE_INPUT);
	im_i_start();
	im_i_clear_cur_history_idx();
	return 0;
}
PRIVATE int im_c_abort_conversion(void)
{
_FLF_
	im_set_mode(IM_UI_MODE_INPUT);
	im_i_cursor_offset = strlen(im_i_pronun);
	return 0;
}

PRIVATE int im_c_select_prev(void)
{
	im_c_check_set_candid_idx(im_c_get_cur_candid_idx()-1);
	return 0;
}
PRIVATE int im_c_select_next(void)
{
	im_c_check_set_candid_idx(im_c_get_cur_candid_idx()+1);
	return 0;
}
PRIVATE int im_c_select_prev_page(void)
{
	im_c_check_set_candid_idx(im_c_get_cur_candid_idx() - im_get_candids_per_page());
	return 0;
}
PRIVATE int im_c_select_next_page(void)
{
	im_c_check_set_candid_idx(im_c_get_cur_candid_idx() + im_get_candids_per_page());
	return 0;
}
PRIVATE int im_c_select_first(void)
{
	im_c_set_cur_candid_idx(0);
	return 0;
}
PRIVATE int im_c_select_last(void)
{
	im_c_set_cur_candid_idx(im_c_get_num_of_candids()-1);
	return 0;
}
PRIVATE int im_c_commit_all(void)
{
	char buffer[IM_INPUT_LINE_LEN+1];

	strlncpy(buffer, IM_INPUT_LINE_LEN, im_i_pronun, im_c_len_to_match);
	imjhst_insert_newest(buffer, im_c_cur_candid);
	imjhst_insert_newest(&im_i_pronun[im_c_len_to_match], &im_i_pronun[im_c_len_to_match]);

	strcpy(buffer, im_c_cur_candid);
	utf8strlcat(buffer, IM_INPUT_LINE_LEN, &im_i_pronun[im_c_len_to_match]);
	im_i_commit_string(buffer);
	im_i_romaji[0] = '\0';
	im_i_pronun[0] = '\0';
	im_c_end_conversion();
	return 0;
}
PRIVATE int im_c_commit_one(void)
{
	char buffer[IM_INPUT_LINE_LEN+1];
	int offset_r;

	strlncpy(buffer, IM_INPUT_LINE_LEN, im_i_pronun, im_c_len_to_match);
	imjhst_insert_newest(buffer, im_c_cur_candid);

	im_i_commit_string(im_c_cur_candid);
	offset_r = atoh_romaji_offset(im_i_romaji, im_c_len_to_match);
	strcpy(im_i_romaji, &im_i_romaji[offset_r]);
	strcpy(im_i_pronun, &im_i_pronun[im_c_len_to_match]);
	im_c_start_conversion();
	return 0;
}
PRIVATE int im_c_hiragana(void)
{
	int offset_r;
	char romaji[IM_INPUT_LINE_LEN+1];

	offset_r = atoh_romaji_offset(im_i_romaji, im_c_len_to_match);
	strlncpy(romaji, IM_INPUT_LINE_LEN, im_i_romaji, offset_r);
	atoh_convert_line(romaji, im_c_cur_candid, IM_INPUT_LINE_LEN);
	imjhira_to_hira(im_c_cur_candid, im_c_cur_candid, IM_INPUT_LINE_LEN);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_c_katakana(void)
{
	int offset_r;
	char romaji[IM_INPUT_LINE_LEN+1];

	offset_r = atoh_romaji_offset(im_i_romaji, im_c_len_to_match);
	strlncpy(romaji, IM_INPUT_LINE_LEN, im_i_romaji, offset_r);
	atoh_convert_line(romaji, im_c_cur_candid, IM_INPUT_LINE_LEN);
	imjhira_to_kata(im_c_cur_candid, im_c_cur_candid, IM_INPUT_LINE_LEN);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_c_hankaku(void)
{
	int offset_r;
	char romaji[IM_INPUT_LINE_LEN+1];

	offset_r = atoh_romaji_offset(im_i_romaji, im_c_len_to_match);
	strlncpy(romaji, IM_INPUT_LINE_LEN, im_i_romaji, offset_r);
	atoh_convert_line(romaji, im_c_cur_candid, IM_INPUT_LINE_LEN);
	imjhira_to_han_kata(im_c_cur_candid, im_c_cur_candid, IM_INPUT_LINE_LEN);
flf_d_printf("im_i_romaji:[%s]\n", im_i_romaji);
flf_d_printf("im_i_pronun:[%s]\n", im_i_pronun);
flf_d_printf("im_c_cur_candid:[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_c_zenkaku_alnum(void)
{
	im_set_mode(IM_UI_MODE_INPUT);
	im_i_zenkaku_alnum();
	return 0;
}
PRIVATE int im_c_hankaku_alnum(void)
{
	im_set_mode(IM_UI_MODE_INPUT);
	im_i_hankaku_alnum();
	return 0;
}
PRIVATE int im_c_left_separation(void)
{
	im_c_len_to_match = utf8s_len_le(im_i_pronun, im_c_len_to_match-1);
	if (im_c_len_to_match == 0)
		im_c_len_to_match = utf8c_bytes(im_i_pronun);	// at least one char
	im_c_search_dic();
	return 0;
}
PRIVATE int im_c_right_separation(void)
{
	im_c_len_to_match = utf8s_len_ge(im_i_pronun, im_c_len_to_match+1);
	im_c_search_dic();
	return 0;
}
PRIVATE int im_c_search_dic(void)
{
	im_c_num_of_candids = 0;
	im_c_cur_candid_idx = 0;
	im_c_cur_candid[0] = '\0';
	if (strlen(im_i_pronun) == 0)
		return 0;
	im_c_len_to_match = imjdichst_search(im_i_pronun, im_c_len_to_match);
	if (im_c_len_to_match == 0)
		im_c_len_to_match = utf8c_bytes(im_i_pronun);	// at least one char
	im_c_num_of_candids = imjcandid_get_num_of_candids();
flf_d_printf("im_c_num_of_candids: %d\n", im_c_num_of_candids);
	im_c_cur_candid_idx = 0;
	if (im_c_num_of_candids == 0) {
_FL_
		strlncpy(im_c_cur_candid, MAX_CANDID_LEN, im_i_pronun, im_c_len_to_match);
	} else {
_FL_
		im_c_get_cur_candid();
	}
flf_d_printf("im_c_cur_candid[%s]\n", im_c_cur_candid);
	return 0;
}
PRIVATE int im_c_get_cur_candid(void)
{
	return imjcandid_get_candid(im_c_cur_candid_idx, im_c_cur_candid, MAX_CANDID_LEN);
}
PRIVATE int im_i_commit_string(char *string)
{
flf_d_printf("im_i_commit_string[%s]\n", string);
	utf8strlcat(im_i_commit_buf, IM_INPUT_LINE_LEN, string);
	return 0;
}

// 辞書+変換ヒストリ複合検索 --------------------------------------------------
//imjdichst_...

// 1: candidates from Conversion history
//    "洗浄"
// 2: candidates from Dictionary
//    "戦場", "船上", "線上", "洗浄"
//// 3: Hiragana, Katakana, Hankaku-Katakana, Zenkaku-ASCII, Hankaku-ASCII
////    "せんじょう", "センジョウ", "ｾﾝｼﾞｮｳ", "ｓｅｎｎｊｙｏｕ", "sennjyou"
PRIVATE int imjdichst_search(char *pronun, int len_to_match)
{
	int dic_match_len;
	int hst_match_len;

flf_d_printf("pronun: [%s]:%d\n", pronun, len_to_match);
	if (len_to_match <= 0) {
		imjcandid_clear_candids();
		dic_match_len = imjdic_search_total_len(pronun, len_to_match);
		hst_match_len = imjchst_search_longest_match(pronun);
		len_to_match = _MAX(dic_match_len, hst_match_len);
	}
	imjcandid_clear_candids();
	imjdic_search_total_len(pronun, len_to_match);
	imjdichst_merge_dic_hst_candids(pronun, len_to_match);
	return len_to_match;
}
PRIVATE int imjdichst_merge_dic_hst_candids(char *pronun, int len_to_match)
{
	int candid_idx;
	char candid[IM_INPUT_LINE_LEN+1];
	int matches;
	int len;

_FLF_
imjcandid_dump_candids();
	matches = imjchst_get_matches(pronun, len_to_match);
	for (candid_idx = matches-1; candid_idx >= 0; candid_idx--) {
		if (imjchst_get_nth_match(candid_idx, pronun, len_to_match, candid, MAX_CANDID_LEN))
			imjcandid_insert_one_candid(candid);
	}

	len = _MIN(IM_INPUT_LINE_LEN, len_to_match);
	utf8strlcpy(candid, len, pronun);
	imjcandid_append_one_candid(candid);		// "かんじ"

	imjhira_to_kata(candid, candid, IM_INPUT_LINE_LEN);
	imjcandid_append_one_candid(candid);		// "カンジ"

	imjhira_to_han_kata(candid, candid, IM_INPUT_LINE_LEN);
	imjcandid_append_one_candid(candid);		// "ｶﾝｼﾞ"

	len = _MIN(IM_INPUT_LINE_LEN, atoh_romaji_offset(im_i_romaji, len_to_match));

	utf8strlcpy(candid, len, im_i_romaji);
	imjhira_to_hira(candid, candid, IM_INPUT_LINE_LEN);
	imjcandid_append_one_candid(candid);		// ”ｋａｎｎｊｉ"

	utf8strlcpy(candid, len, im_i_romaji);
	imjhira_to_han_kata(candid, candid, IM_INPUT_LINE_LEN);
	imjcandid_append_one_candid(candid);		// "kannji"
_FLF_
imjcandid_dump_candids();
	return 0;
}

// 辞書検索 -------------------------------------------------------------------
//imjdic_...

FILE *fp_dic = NULL;
long dic_record_offsets[MAX_DIC_RECORDS];
int dic_num_of_records = 0;

// Dictionary search statistics
static int dic_search_words = 0;
static int dic_search_records = 0;
static int dic_max_search_records = 0;
static int dic_total_search_records = 0;
static int dic_avg_search_records = 0;	// average records searched per word

PRIVATE int imjdic_read_record(long offset, char *buffer, int buf_len);
PRIVATE int imjdic_get_offsets_of_all_records(void);
PRIVATE void imjdic_dump_all_tangos(void);
PRIVATE char *strip_hinshi_code(char *hinshi_code);

int imjdic_open(const char *file_path)
{
	if (file_path == NULL)
		file_path = DIC_FILE_NAME;
flf_d_printf("dic-file-path:[%s]\n", file_path);
	if ((fp_dic = fopen(file_path, "r")) == NULL) {
		_ERR_
		return 1;
	}
	imjdic_get_offsets_of_all_records();
//	imjdic_dump_all_tangos();
//	imjdic_sort();
	return 0;
}
int imjdic_close(void)
{
	int ret = 0;

	if (fp_dic) {
		if (fclose(fp_dic) < 0) {
			_FL_
			ret = 1;
		}
		fp_dic = NULL;
	}
	return ret;
}
PRIVATE int imjdic_read_record(long offset, char *buffer, int buf_len)
{
	dic_search_records++;
	if (offset >= 0)
		fseek(fp_dic, offset, SEEK_SET);
	if (fgets(buffer, buf_len, fp_dic) == NULL) {
		return -1;
	}
	cut_line_tail_crlf(buffer);
	return 0;
}

PRIVATE int imjdic_get_offsets_of_all_records(void)
{
	int idx;
	char dic_rec[MAX_DIC_LINE_LEN+1];

	fseek(fp_dic, 0, SEEK_SET);
	for (idx = 0; idx < MAX_DIC_RECORDS; idx++) {
		dic_record_offsets[idx] = ftell(fp_dic);
		if (imjdic_read_record(-1, dic_rec, MAX_DIC_LINE_LEN) < 0) {
			break;
		}
	}
	dic_num_of_records = idx;
//flf_d_printf("total dic records: %d\n", dic_num_of_records);
	return 0;
}

PRIVATE int imjdic_qsort_compare(const void *aa, const void *bb);

int imjdic_sort(void)
{
flf_d_printf("sorting dictionary %d records...\n", dic_num_of_records);
	qsort(dic_record_offsets, dic_num_of_records, sizeof(long), imjdic_qsort_compare);
flf_d_printf("sorting complete.\n");
flf_d_printf("dic_search_records: %d\n", dic_search_records);
	return 0;
}
// Sort dictionary lines by character code.
PRIVATE int imjdic_qsort_compare(const void *aa, const void *bb)
{
	char line_a[MAX_DIC_LINE_LEN+1];
	char line_b[MAX_DIC_LINE_LEN+1];
	int ret;

	fseek(fp_dic, *(const long *)aa, SEEK_SET);
	if (fgets(line_a, MAX_DIC_LINE_LEN, fp_dic) == NULL) {
		return 0;
	}
	fseek(fp_dic, *(const long *)bb, SEEK_SET);
	if (fgets(line_b, MAX_DIC_LINE_LEN, fp_dic) == NULL) {
		return 0;
	}
	ret = strcmp(line_a, line_b);
//flf_d_printf("%s%s%s\n",
// line_a,
// ret > 0 ? " > " : (ret < 0 ? " < " : " = "),
// line_b);
	return ret;
}

PRIVATE void imjdic_dump_all_tangos(void)
{
	int rec_idx;
	char dic_rec[MAX_DIC_LINE_LEN+1];
	int candids;
	int candid_idx;
	char pronun[MAX_CANDID_LEN+1];
	char gokan[MAX_CANDID_LEN+1];
	char hinshi[MAX_CANNA_HINSHI_CODE_LEN+1];
#define	MAX_KATSUYOU_LIST_LEN	500
	char katsuyou[MAX_KATSUYOU_LIST_LEN+1];
	char buffer[MAX_DIC_LINE_LEN+1];

	for (rec_idx = 0; rec_idx < MAX_DIC_RECORDS; rec_idx++) {
		if (imjdic_read_record(dic_record_offsets[rec_idx], dic_rec, MAX_DIC_LINE_LEN) < 0) {
			break;
		}
		imjdic_get_pronun(dic_rec, pronun, MAX_CANDID_LEN);
//		flf_d_printf("$%s\n", pronun);
		candids = imjdic_get_num_of_candids(dic_rec);
		for (candid_idx = 0; candid_idx < candids; candid_idx++) {
			imjdic_get_one_gokan__hinshi(dic_rec, candid_idx, gokan, MAX_CANDID_LEN, hinshi);
			imjkat_get_katsuyou_from_hinshi_code(hinshi, katsuyou, MAX_KATSUYOU_LIST_LEN);
			concat_bunsetsu(gokan, katsuyou, buffer, MAX_DIC_LINE_LEN);
			if (*katsuyou)
				flf_d_printf("#%s [%s]\n", hinshi, buffer);
		}
	}
}

struct bsearch_key {
	char *pronun;				// I:search key
	int len_to_match;			// I:length to compare
};

PRIVATE long bsearch_match_offset;

int imjdic_search_total_len(char *pronun, int len_to_match)
{
	int gokan_len_to_match;				// len of "か"
///	int katsuyou_len_to_match = 0;		// len of "かいます"
	int match_len;
	int max_match_len;

flf_d_printf("pronun:[%s], len_to_match: %d\n", pronun, len_to_match);
	if (strlen(pronun) == 0)
		return 0;

	dic_search_words++;
	dic_search_records = 0;
	if (len_to_match <= 0) {
		// determine len_to_match
		max_match_len = 0;
		for (gokan_len_to_match = utf8c_bytes(pronun); ;	// one char ...
		 gokan_len_to_match = utf8s_len_ge(pronun, gokan_len_to_match+1)) {
//flf_d_printf("gokan_len_to_match: %d\n", gokan_len_to_match);
			match_len = imjdic_search_gokan_len(pronun, gokan_len_to_match, 0);
			max_match_len = _MAX(max_match_len, match_len);
			if (gokan_len_to_match >= _MIN((int)strlen(pronun), MAX_DIC_PRONUN_LEN))
				break;
		}
		len_to_match = max_match_len;
		if (len_to_match <= 0) {
			len_to_match = utf8c_bytes(pronun);	// one char
		}
flf_d_printf("pronun:[%s], len_to_match: %d, max_match_len: %d\n", pronun, len_to_match, max_match_len);
	}
	max_match_len = 0;
	for (gokan_len_to_match = utf8c_bytes(pronun); ;
	 gokan_len_to_match = utf8s_len_ge(pronun, gokan_len_to_match+1)) {
//flf_d_printf("gokan_len_to_match: %d, katsuyou_len_to_match: %d\n", gokan_len_to_match, katsuyou_len_to_match);
		match_len = imjdic_search_gokan_len(pronun, gokan_len_to_match, len_to_match);
		max_match_len = _MAX(max_match_len, match_len);
		if (gokan_len_to_match >= _MIN((int)strlen(pronun), MAX_DIC_PRONUN_LEN))
			break;
	}
flf_d_printf("pronun:[%s], len_to_match: %d, max_match_len: %d\n", pronun, len_to_match, max_match_len);
	imjdic_dump_search_stats(pronun);
	return max_match_len;
}

int imjdic_bsearch_compare(const void *key, const void *element);
int imjdic_compare_katsuyou(char *dic_rec, char *pronun, int gokan_len, int expanded_len);

int imjdic_search_gokan_len(char *pronun, int gokan_len_to_match, int katsuyou_len_to_match)
{
	struct bsearch_key key;
	long *result_of_search;
	char dic_rec[MAX_DIC_LINE_LEN+1];
	int match_len = 0;

	if (fp_dic == NULL)
		return 0;
flf_d_printf("pronun:[%s], gokan_len_to_match: %d, katsuyou_len_to_match: %d\n",
 pronun, gokan_len_to_match, katsuyou_len_to_match);
	key.pronun = pronun;
	key.len_to_match = gokan_len_to_match;
	bsearch_match_offset = 0;
	result_of_search = (long *)bsearch(&key, dic_record_offsets, dic_num_of_records, sizeof(long),
	 imjdic_bsearch_compare);
	if (result_of_search) {
		if (imjdic_read_record(bsearch_match_offset, dic_rec, MAX_DIC_LINE_LEN) >= 0) {
flf_d_printf("dic_rec: [%s]\n", dic_rec);
			match_len = imjdic_compare_katsuyou(dic_rec, pronun, gokan_len_to_match, katsuyou_len_to_match);
		}
	}
flf_d_printf("pronun:[%s], match_len: %d\n", pronun, match_len);
	return match_len;
}
int imjdic_bsearch_compare(const void *key, const void *element)
{
	const struct bsearch_key *key_ptr;
	char *pronun;
	int len_to_match;
	long match_offset;
	char dic_rec[MAX_DIC_LINE_LEN+1];
	int candid_len;
	int cmp;
	int match_len = 0;
	int ret = 0;

	key_ptr = (const struct bsearch_key *)key;
	match_offset = *(const long *)element;
	pronun = key_ptr->pronun;
	len_to_match = key_ptr->len_to_match;
	if (imjdic_read_record(match_offset, dic_rec, MAX_DIC_LINE_LEN) < 0) {
		return -1;
	}
	candid_len = imjdic_candidate_len(dic_rec);
//flf_d_printf("dic_rec: %d,[%s]\n", match_len, dic_rec);
	// 指定長一致
	if (len_to_match == candid_len) {			// "ABC" "ABC"
		cmp = strncmp(pronun, dic_rec, len_to_match);
		ret = cmp;
		match_len = len_to_match;
//flf_d_printf("%2d:[%s]%s[%s]\n", len_to_match, pronun,
// ret > 0 ? " > " : (ret < 0 ? " < " : " = "),
// dic_rec);
	} else if (len_to_match > candid_len) {	// "ABC" "AB"
		cmp = strncmp(pronun, dic_rec, candid_len);
		ret = cmp;
		if (ret == 0) {
			ret = +1;
			match_len = candid_len;
		}
//flf_d_printf("%2d:[%s]%s[%s]\n", candid_len, pronun,
// ret > 0 ? " > " : (ret < 0 ? " < " : " = "),
// dic_rec);
	} else if (len_to_match < candid_len) {	// "ABC" "ABCD"
		cmp = strncmp(pronun, dic_rec, len_to_match);
		ret = cmp;
		if (ret == 0) {
			ret = -1;
			match_len = len_to_match;
		}
//flf_d_printf("%2d:[%s]%s[%s]\n", len_to_match, pronun,
// ret > 0 ? " > " : (ret < 0 ? " < " : " = "),
// dic_rec);
	}
	bsearch_match_offset = match_offset;
	return ret;
}
int imjdic_compare_katsuyou(char *dic_rec, char *pronun, int gokan_len, int katsuyou_len_to_match)
{
	int candids;
	int candid_idx;
	char gokan[MAX_CANDID_LEN+1];
	char hinshi[MAX_CANNA_HINSHI_CODE_LEN+1];
	char expanded[MAX_CANDID_LEN+1];
	char katsuyou[MAX_KATSUYOU_LIST_LEN+1];
	char *ptr_k;
	int katsuyou_len;
	int katsuyou_match_len = 0;

flf_d_printf("pronun:[%s], katsuyou:[%s], gokan_len:%d, katsuyou_len_to_match:%d\n",
 pronun, &pronun[gokan_len], gokan_len, katsuyou_len_to_match);
///	if (strlen(&pronun[gokan_len]) == 0) {	// no katsuyou part
///_FLF_
///		return gokan_len;
///	}
	candids = imjdic_get_num_of_candids(dic_rec);
flf_d_printf("candids: %d\n", candids);
	for (candid_idx = 0; candid_idx < candids; candid_idx++) {
		imjdic_get_one_gokan__hinshi(dic_rec, candid_idx, gokan, MAX_CANDID_LEN, hinshi);
		imjkat_get_katsuyou_from_hinshi_code(hinshi, katsuyou, MAX_KATSUYOU_LIST_LEN);
		for (ptr_k = katsuyou; ; ptr_k += next_word(ptr_k)) {
///flf_d_printf("ptr_k: [%s]\n", ptr_k);
			if (katsuyou_len_to_match <= 0) {
				// 最長一致
///flf_d_printf("[%s] ?? %d:[%s]\n", &pronun[gokan_len], word_len(ptr_k), ptr_k);
				if (strncmp(&pronun[gokan_len], ptr_k, word_len(ptr_k)) == 0) {
					katsuyou_match_len = _MAX(word_len(ptr_k), katsuyou_match_len);
				}
			} else {
				// 指定長一致
				katsuyou_len = katsuyou_len_to_match - gokan_len;
///flf_d_printf("%d:[%s] ?? [%s]\n", katsuyou_len, &pronun[gokan_len], ptr_k);
				if (word_len(ptr_k) == katsuyou_len
				 && strncmp(&pronun[gokan_len], ptr_k, word_len(ptr_k)) == 0) {
					strcpy(expanded, gokan);
					utf8strlncat(expanded, MAX_CANDID_LEN, ptr_k, word_len(ptr_k));	// "買" + "います"
					imjcandid_append_one_candid(expanded);
					katsuyou_match_len = katsuyou_len;
				}
			}
			if (*ptr_k == '\0')
				break;
		}
	}
imjcandid_dump_candids();
	return gokan_len + katsuyou_match_len;
}

int imjdic_dump_search_stats(char *pronun)
{
flf_d_printf("(((((((((((((((((((((((((((((((((((((((((((((((((\n");
flf_d_printf("dic_search_records: %d:[%s]\n", dic_search_records, pronun);
	dic_max_search_records = _MAX(dic_search_records, dic_max_search_records);
flf_d_printf("dic_max_search_records: %d\n", dic_max_search_records);
	dic_total_search_records += dic_search_records;
	dic_avg_search_records = dic_total_search_records / (dic_search_words == 0 ? 1 : dic_search_words);
flf_d_printf("dic_search_words: %d\n", dic_search_words);
flf_d_printf("dic_avg_search_records: %d\n", dic_avg_search_records);
flf_d_printf(")))))))))))))))))))))))))))))))))))))))))))))))))\n");
	return 0;
}

int imjdic_get_pronun(char *dic_rec, char *pronun, int buf_len)
{
	int len;

	len = imjdic_candidate_len(dic_rec);
	strlncpy(pronun, buf_len, dic_rec, len);
	return len;
}
int imjdic_get_num_of_candids(char *dic_rec)
{
	char *ptr;
	int can_cnt;
	int prev_is_sharp;

	ptr = dic_rec;
	ptr += imjdic_next_candidate(ptr);
	prev_is_sharp = 0;
	for (can_cnt = 0; *ptr; ) {
//flf_d_printf("%d:[%s]\n", can_cnt, ptr);
		if (prev_is_sharp == 0 && *ptr == '#') {
			prev_is_sharp = 1;
		} else {
			// not type but a candidate
			prev_is_sharp = 0;
			can_cnt++;
		}
		ptr += imjdic_next_candidate(ptr);
	}
	return can_cnt;
}
int imjdic_get_one_gokan__hinshi(char *dic_rec, int candid_idx,
 char *gokan, int buf_len, char *hinshi_code)
{
	char *ptr;
	char *ptr_hinshi = NULL;
	int can_cnt;
	int prev_is_sharp;

	gokan[0] = '\0';
	ptr = dic_rec;
	ptr += imjdic_next_candidate(ptr);
	prev_is_sharp = 0;
	for (can_cnt = 0; *ptr; ) {
//flf_d_printf("%d:[%s]\n", can_cnt, ptr);
		if (prev_is_sharp == 0 && *ptr == '#') {	// 品詞コード
			ptr_hinshi = ptr;
			prev_is_sharp = 1;
		} else {
			// not type but a candidate
			prev_is_sharp = 0;
			if (can_cnt >= candid_idx)
				break;
			can_cnt++;
		}
		ptr += imjdic_next_candidate(ptr);
	}
	utf8strlncpy(gokan, buf_len, ptr, imjdic_candidate_len(ptr));
	if (hinshi_code) {
		strlncpy(hinshi_code, MAX_CANNA_HINSHI_CODE_LEN,
		 ptr_hinshi, imjdic_candidate_len(ptr_hinshi));
		strcpy(hinshi_code, strip_hinshi_code(hinshi_code));
	}
//flf_d_printf("imjdic_get_one_gokan__hinshi(%d):[%s]:[%s]\n",
// candid_idx, gokan, hinshi_code);
	return strlen(gokan);
}

// "#K5*500" ==> "K5"
PRIVATE char *strip_hinshi_code(char *hinshi_code)
{
	char *ptr;

	if (hinshi_code[0] == '#')
		hinshi_code++;		// "#K5*500" ==> "K5*500"
	for (ptr = hinshi_code; *ptr; ptr++) {
		if (*ptr == '*')
			*ptr = '\0';	// "K5*500" ==> "K5"
	}
	return hinshi_code;
}

int imjdic_next_candidate(char *dic_rec)
{
	char *ptr;

	ptr = dic_rec;
	ptr += imjdic_candidate_len(ptr);
	ptr += space_len(ptr);
	return ptr - dic_rec;
}
int imjdic_candidate_len(char *dic_rec)
{
	char *ptr;

	ptr = dic_rec;
	if (*ptr)
		ptr++;		// skip one char even if it is ' '
	for ( ; *ptr; ptr++) {
		if (*ptr == ' ')
			break;
	}
	return ptr - dic_rec;
}

// 動詞/形容詞 活用 -------------------------------------------------------------------------
//imjkatsuyou_...

static const char *katsuyou_table[] = {
// canna-dic品詞コード  活用RegExp
// 動詞
 "abcdefg",
 "K5   く(|な)|か(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |き(|た|たい|ま|ます|ませ|まし)|け(|ば|る|な|ない|ぬ)|こ(|う)|い(た|ちゃ|     て|と)",
 "C5r  く(|な)|か(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |き(|た|たい|ま|ます|ませ|まし)|け(|ば|る|な|ない|ぬ)|こ(|う)|っ(た|ちゃ|     て|と)",
 "G5   ぐ(|な)|が(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |ぎ(|た|たい|ま|ます|ませ|まし)|げ(|ば|る|な|ない|ぬ)|ご(|う)|い(だ|ぢゃ|じゃ|で|ど)",
 "S5   す(|な)|さ(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |し(|た|たい|ま|ます|ませ|まし)|せ(|ば|る|な|ない|ぬ)|そ(|う)|し(た|ちゃ|     て|と)",
 "T5   つ(|な)|た(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |ち(|た|たい|ま|ます|ませ|まし)|て(|ば|る|な|ない|ぬ)|と(|う)|っ(た|ちゃ|     て|と)",
 "N5   ぬ(|な)|な(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |に(|た|たい|ま|ます|ませ|まし)|ね(|ば|る|な|ない|ぬ)|の(|う)|ん(だ|ぢゃ|じゃ|で|ど)",
 "B5   ぶ(|な)|ば(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |び(|た|たい|ま|ます|ませ|まし)|べ(|ば|る|な|ない|ぬ)|ぼ(|う)|ん(だ|ぢゃ|じゃ|で|ど)",
 "M5   む(|な)|ま(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |み(|た|たい|ま|ます|ませ|まし)|め(|ば|る|な|ない|ぬ)|も(|う)|ん(だ|ぢゃ|じゃ|で|ど)",
 "R5   る(|な)|ら(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |り(|た|たい|ま|ます|ませ|まし)|れ(|ば|る|な|ない|ぬ)|ろ(|う)|っ(た|ちゃ|     て|と)",
 "W5   う(|な)|わ(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |い(|た|たい|ま|ます|ませ|まし)|え(|ば|る|な|ない|ぬ)|お(|う)|っ(た|ちゃ|     て|と)",
 "KS   る(|な)|    な|ない|なけれ|なければ|ず|ぬ|ねば|ん|(|ら)(れ|れる)|らるる|    た|たい|ま|ます|ませ|まし |れ(|ば|る|な|ない|ぬ)|よ(|う)|   た|ちゃ|     て|と|ろ",
 "SX する(|な)|さ(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |し(|た|たい|ま|ます|ませ|まし)|せ(|ば|る|な|ない|ぬ)|そ(|う)|し(た|ちゃ|     て|と)   |すれば",
 "ZX ずる(|な)|じ(|な|ない|なけれ|なければ|ず|ぬ|ねば|   (|ら)(れ|れる)|らるる|    た|たい|ま|ます|ませ|まし |れ(|ば|る|な|ない|ぬ)|よ(|う)|   た|ちゃ|     て|と|ろ)|ずれば",
 "L5   る(|な)|ら(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |り(|た|たい|ま|ます|ませ|まし)|れ(|ば|る|な|ない|ぬ)|ろ(|う)|っ(た|ちゃ|     て|と)   |い(|ま|ます|ませ|まし)",
 "U5   う(|な)|わ(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |い(|た|たい|ま|ます|ませ|まし)|え(|ば|る|な|ない|ぬ)|お(|う)|う(た|ちゃ|     て|と)",
 "aru  る(|な)|ら(|な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|るる)        |り(|た|たい|ま|ます|ませ|まし)|れ(|ば|る|な|ない|ぬ)|ろ(|う)|っ(た|ちゃ|     て|と)",
 "kxuru   |な",
 "kxure                                                                            た|     ま|ます|ませ|まし |れば  |る|な|ない|ぬ               |ちゃ|     て|と)",
 "kxi                                                                            ( た|たい|ま|ます|ませ|まし)|                                (た|ちゃ|     て|と)",
 "kxo              な|ない|なけれ|なければ|ず|ぬ|ねば|ん|(|ら)(れ|れる)|らるる|                                                     よ(|う)|い",
 "sxu2 る(|な)|                                                                                               れば",
 "sxi              な|ない|なけれ|なければ|ず                                 |    た|たい|ま|ます|ませ|まし |                      よ(|う)|   た|ちゃ|     て|と|ろ",
 "sxe                                      ず|ぬ|ねば|ん|( ら)(れ|れる)|                                                            よ",
// 形容詞
 "KY   い | く(|な|ない) | かっ(|た) | けれ(|ば) | かろ(|う) | き | かれ",
 ""
};

void imj_test_expand_katsuyou(void)
{
#if 0
	char *str1;
	char *str2;
	char *re;
#endif
	int max_katsuyou_len = 0;
	int gokan_idx;
	char katsuyou[MAX_KATSUYOU_LIST_LEN+1];
	char buffer[MAX_DIC_LINE_LEN+1];
	const char *test_katsuyou[] = {
	 "K5    書",
	 "C5r   行",
	 "G5    漕",
	 "S5    消",
	 "T5    勝",
	 "N5    死",
	 "B5    呼",
	 "M5    読",
	 "R5    知",
	 "W5    笑",
	 "KS    見",
	 "SX    資",
	 "ZX    演",
	 "L5    なさ",
	 "U5    問",
	 "aru   有",
	 "kxuru 見てくる",
	 "kxure 見てくれ",
	 "kxi   来",
	 "kxo   来",
	 "sxu2  す",
	 "sxi   し",
	 "sxe   せ",
	 "KY    美し",
	 ""
	};

#if 0
	str1 = "abc ";
	str2 = "def ";
	concat_bunsetsu(str1, str2, buffer, MAX_DIC_LINE_LEN);
	flf_d_printf("[%s]+[%s]\n==>\n[%s]\n", str1, str2, buffer);
	str1 = "a b";
	str2 = "c d e";
	concat_bunsetsu(str1, str2, buffer, MAX_DIC_LINE_LEN);
	flf_d_printf("[%s]+[%s]\n==>\n[%s]\n", str1, str2, buffer);
	str1 = "";
	str2 = "c d e";
	concat_bunsetsu(str1, str2, buffer, MAX_DIC_LINE_LEN);
	flf_d_printf("[%s]+[%s]\n==>\n[%s]\n", str1, str2, buffer);
	str1 = "a b c";
	str2 = "";
	concat_bunsetsu(str1, str2, buffer, MAX_DIC_LINE_LEN);
	flf_d_printf("[%s]+[%s]\n==>\n[%s]\n", str1, str2, buffer);
//	re = "(c|d)";
//	expand_regexp(re, "a b ", buffer, MAX_KATSUYOU_LIST_LEN);
//	flf_d_printf("[%s]\n==>\n[%s]\n", re, buffer);
	re = "あい うえ おか";
	expand_regexp(re, buffer, MAX_KATSUYOU_LIST_LEN);
	flf_d_printf("[%s]\n==>\n[%s]\n----\n", re, buffer);
	re = "(あ|い)(う|え)";
	expand_regexp(re, buffer, MAX_KATSUYOU_LIST_LEN);
	flf_d_printf("[%s]\n==>\n[%s]\n----\n", re, buffer);
	re = "か(|な|ない|(|ら)(れ|れる))";
	expand_regexp(re, buffer, MAX_KATSUYOU_LIST_LEN);
	flf_d_printf("[%s]\n==>\n[%s]\n----\n", re, buffer);
	re = "か(|な|ない|(|ら)(れ|れる))|き(|た|たい|ま|ます|ませ|まし)";
	expand_regexp(re, buffer, MAX_KATSUYOU_LIST_LEN);
	flf_d_printf("[%s]\n==>\n[%s]\n----\n", re, buffer);
	re = "じ((|な|ない|れ|れる|る|るる)|(|た|たい|ま|ます|ませ|まし))";
	expand_regexp(re, buffer, MAX_KATSUYOU_LIST_LEN);
	flf_d_printf("[%s]\n==>\n[%s]\n----\n", re, buffer);
#endif
	for (gokan_idx = 0; test_katsuyou[gokan_idx][0]; gokan_idx++) {
		imjkat_get_katsuyou_from_hinshi_code(test_katsuyou[gokan_idx], katsuyou, MAX_KATSUYOU_LIST_LEN);
		max_katsuyou_len = _MAX(max_katsuyou_len, strlen(katsuyou));
		concat_bunsetsu(&test_katsuyou[gokan_idx][next_word(test_katsuyou[gokan_idx])], katsuyou,
		 buffer, MAX_DIC_LINE_LEN);
		flf_d_printf("[%s]\n[%s]\n", test_katsuyou[gokan_idx], buffer);
	}
flf_d_printf("max_katsuyou_len: %d\n", max_katsuyou_len);
}

// "K5" ==> "く くな か かな かない ..."
char *imjkat_get_katsuyou_from_hinshi_code(const char *code, char *buffer, int buf_len)
{
	int tbl_idx;

	buffer[0] = '\0';
	for (tbl_idx = 0; katsuyou_table[tbl_idx][0]; tbl_idx++) {
//flf_d_printf("katsuyou_table[%d]:[%s]\n", tbl_idx, katsuyou_table[tbl_idx]);
		if (word_len(code) == word_len(katsuyou_table[tbl_idx])
		 && strncmp(code, katsuyou_table[tbl_idx], word_len(code)) == 0) {
			expand_regexp(&katsuyou_table[tbl_idx][next_word(katsuyou_table[tbl_idx])], buffer, buf_len);
		}
	}
//flf_d_printf("katsuyou_code: [%s] ==> katsuyou: [%s]\n", code, buffer);
	return buffer;
}

#define	MAX_KATSUYOU_LEN	(3*20)	// じなければ
// regexp = bunsetsu | bunsetsu ...
// bunsetsu = chars chars ...
// chars = ( exgexp )
// な|ない|なけれ|なければ|ず|ぬ|ねば|ん|れ|れる|る|るる
// か(|な|ない|(|ら)(れ|れる))
const char *expand_regexp(const char *regexp, char *buf_ret, int buf_len)
{
	return parse_re_parallel(regexp, buf_ret, buf_len);
}

// "abc|def|ghi" ==> "abc def ghi"
const char *parse_re_parallel(const char *regexp, char *buf_ret, int buf_len)
{
	const char *ptr_re;
	char bunsetsu[MAX_KATSUYOU_LIST_LEN+1];

//_FLFE_
//flf_d_printf("regexp:[%s]\n", regexp);
	buf_ret[0] = '\0';
	for (ptr_re = regexp; *ptr_re; ) {
//flf_d_printf("ptr_re:[%s]\n", ptr_re);
		ptr_re = skip_space(ptr_re);
		ptr_re = parse_re_bunsetsu(ptr_re, bunsetsu, MAX_KATSUYOU_LIST_LEN);
		utf8strlcat(buf_ret, buf_len, bunsetsu);
		ptr_re = skip_space(ptr_re);
//flf_d_printf("ptr_re:[%s]\n", ptr_re);
		if (*ptr_re == '|') {
			ptr_re++;
		} else {
			break;
		}
		add_space_separator(buf_ret, buf_len);
//flf_d_printf("buf_ret:[%s]\n", buf_ret);
	}
//flf_d_printf("[%s]\n==>\n[%s]\n", regexp, buf_ret);
//_FLFL_
	return ptr_re;
}
// "abc def ghi" ==> "abcdefghi"
// "(a|b)(c|d|e)" ==> "ac ad ae bc bd be"
const char *parse_re_bunsetsu(const char *regexp, char *buf_ret, int buf_len)
{
	const char *ptr_re;
	char bunsetsu[MAX_KATSUYOU_LIST_LEN+1];
	char buf_call[MAX_KATSUYOU_LIST_LEN+1];

//_FLFE_
//flf_d_printf("regexp:[%s]\n", regexp);
	buf_ret[0] = '\0';
	for (ptr_re = regexp; *ptr_re; ) {
//flf_d_printf("ptr_re:[%s]\n", ptr_re);
		ptr_re = parse_re_chars(ptr_re, bunsetsu, MAX_KATSUYOU_LIST_LEN);
//flf_d_printf("ptr_re:[%s]\n", ptr_re);
		concat_bunsetsu(buf_ret, bunsetsu, buf_call, MAX_KATSUYOU_LIST_LEN);
		utf8strlcpy(buf_ret, buf_len, buf_call);
		if (*ptr_re == '|' || *ptr_re == ')') {
			break;
		}
//flf_d_printf("[%s],[%s]\n", regexp, buf_ret);
	}
//_FLFL_
	return ptr_re;
}
// "(abc|def|ghi)" ==> "abc def ghi"
const char *parse_re_chars(const char *regexp, char *buf_ret, int buf_len)
{
	const char *ptr_re;
	char bunsetsu[MAX_KATSUYOU_LIST_LEN+1];
	int len;

//_FLFE_
//flf_d_printf("regexp:[%s]\n", regexp);
	buf_ret[0] = '\0';
	ptr_re = regexp;
	ptr_re = skip_space(ptr_re);
//flf_d_printf("ptr_re:[%s]\n", ptr_re);
	if (*ptr_re == '(') {
		ptr_re++;
		ptr_re = parse_re_parallel(ptr_re, bunsetsu, MAX_KATSUYOU_LIST_LEN);
		utf8strlcat(buf_ret, buf_len, bunsetsu);
		if (*ptr_re == ')') {
			ptr_re++;
		}
	} else {
		len = re_word_len(ptr_re);
		utf8strlncat(buf_ret, buf_len, ptr_re, len);
		ptr_re += len;
	}
//flf_d_printf("ptr_re:[%s]\n", ptr_re);
//flf_d_printf("[%s]\n==>\n[%s]\n", regexp, buf_ret);
//_FLFL_
	return ptr_re;
}
// "abc" + "def" ==> "abcdef"
//	"a b" + "c d e" ==> "ac ad ae bc bd be"
//	"" + "c d e" ==> "c d e"
char *concat_bunsetsu(const char *bunsetsu1, const char *bunsetsu2, char *buffer, int buf_len)
{
	const char *ptr_b1;
	const char *ptr_b2;
	char bunsetsu[MAX_KATSUYOU_LEN+1];

//_FLFE_
//flf_d_printf("[%s]+[%s]\n", bunsetsu1, bunsetsu2);
	buffer[0] = '\0';
	for (ptr_b1 = bunsetsu1; ; ) {
		for (ptr_b2 = bunsetsu2; ; ) {
//flf_d_printf("ptr_b1:[%s]\n", ptr_b1);
//flf_d_printf("ptr_b2:[%s]\n", ptr_b2);
//			ptr_b1 = skip_space(ptr_b1);
			utf8strlncpy(bunsetsu, MAX_KATSUYOU_LEN, ptr_b1, word_len(ptr_b1));
//			ptr_b2 = skip_space(ptr_b2);
			utf8strlncat(bunsetsu, MAX_KATSUYOU_LEN, ptr_b2, word_len(ptr_b2));
			utf8strlcat(buffer, buf_len, bunsetsu);
			strlcat(buffer, " ", buf_len);
//flf_d_printf("buffer:[%s]\n", buffer);
			ptr_b2 += next_word(ptr_b2);
			if (*ptr_b2 == '\0')
				break;
		}
		ptr_b1 += next_word(ptr_b1);
		if (*ptr_b1 == '\0')
			break;
	}
//flf_d_printf("[%s]+[%s]\n==>\n[%s]\n", bunsetsu1, bunsetsu2, buffer);
//_FLFL_
	return buffer;
}
int re_word_len(const char *str)
{
	const char *ptr;

	for (ptr = str; *ptr; ) {
//flf_d_printf("ptr:[%s]\n", ptr);
		switch(*ptr) {
		case ' ':
		case '(':
		case ')':
		case '|':
			goto re_word_len_break;
		default:
			ptr += utf8c_bytes(ptr);
			break;
		}
	}
re_word_len_break:;
//flf_d_printf("ptr:[%s]\n", ptr);
	return ptr - str;
}
void add_space_separator(char *buf, int buf_len)
{
	if (buf[0]) {
		if (buf[strlen(buf)-1] != ' ') {
			strlcat(buf, " ", buf_len);
		}
	}
}

// Simple Conversion History --------------------------------------------------
//imjhst_...

int imjhst_load(const char *file_path)
{
	FILE *fp_cnvhst;
	char line[MAX_HISTORY_LINE_LEN+1];
	char pronun[MAX_HISTORY_PRONUN_LEN+1];

	if (file_path == NULL)
		file_path = CNVHST_FILE_NAME;
	strlcpy(imjhst_file_path, file_path, MAX_PATH_LEN);
flf_d_printf("hst-file-path:[%s]\n", file_path);
	if ((fp_cnvhst = fopen(file_path, "r")) == NULL) {
		_ERR_
		return 1;
	}
	for ( ; imjhst_get_entries() < MAX_CONVERSION_HISTORIES; ) {
		if (fgets(line, MAX_HISTORY_LINE_LEN, fp_cnvhst) == NULL) {
			break;
		}
		cut_line_tail_crlf(line);
		strlncpy(pronun, MAX_HISTORY_PRONUN_LEN, line, word_len(line));
		imjhst_append_entry(pronun, &line[next_word(line)]);
	}
	if (fclose(fp_cnvhst) < 0) {
		_FL_
		return 2;
	}
	return 0;
}
int imjhst_save_if_updated(char *file_path)
{
	if (imjhst_is_updated()) {
		imjhst_clear_updated();
		return imjhst_save(file_path);
	}
	return 0;
}
int imjhst_save(const char *file_path)
{
	FILE *fp_cnvhst;
	int entry_idx;
	char line[MAX_HISTORY_LINE_LEN+1];
	char pronun[MAX_HISTORY_PRONUN_LEN+1];
	char converted[MAX_HISTORY_CONVERTED_LEN+1];

_FLF_
	if (file_path == NULL) {
		if (imjhst_file_path[0])
			file_path = imjhst_file_path;
		else
			file_path = CNVHST_FILE_NAME;
	}
flf_d_printf("hst-file-path:[%s]\n", file_path);
	if ((fp_cnvhst = fopen(file_path, "w")) == NULL) {
		_ERR_
		return 1;
	}
	for (entry_idx = 0; entry_idx < imjhst_get_entries(); entry_idx++) {
		imjhst_get_entry(entry_idx, pronun, converted);
		if (strlen(pronun)) {
///		if (strlen(pronun) && strlen(converted)) {
			snprintf(line, MAX_HISTORY_LINE_LEN+1, "%s %s\n", pronun, converted);
//flf_d_printf("%s", line);
			if (fputs(line, fp_cnvhst) < 0) {
				break;
			}
		}
	}
	if (fclose(fp_cnvhst) < 0) {
		_FL_
		return 3;
	}
_FLF_
	return 0;
}
//=============================================================================
//imjihst_... : input history
//imjchst_... : conversion history
//imjhst_...  : history common to conversion and input

struct _imjhst_ {
	char pronun[MAX_HISTORY_PRONUN_LEN+1];
	char conversion[MAX_HISTORY_CONVERTED_LEN+1];
};
int _imjhst_history_updated = 0;
int _imjhst_history_entries = 0;		// num of entries
struct _imjhst_ _imjhst_history[MAX_CONVERSION_HISTORIES];
#define	IS_IHST(pronun, conversion)		(strlen(pronun) && strlen(conversion) == 0)
#define	IS_CHST(pronun, conversion)		(strlen(pronun) && strlen(conversion))

//-----------------------------------------------------------------------------

PRIVATE int imjihst_get_histories(void)
{
	int entry_idx;
	int histories;

	histories = 0;
	for (entry_idx = 0; entry_idx < _imjhst_history_entries; entry_idx++) {
		if (IS_IHST(_imjhst_history[entry_idx].pronun, _imjhst_history[entry_idx].conversion)) {
			histories++;
		}
	}
flf_d_printf("imjihst_get_histories() ==> %d\n", histories);
	return histories;
}
PRIVATE int imjihst_get_nth_history(int hist_idx, char *history, int buf_len)
{
	int entry_idx;
	int histories;

flf_d_printf("imjihst_get_nth_history(%d)\n", hist_idx);
	histories = 0;
	for (entry_idx = 0; entry_idx < _imjhst_history_entries; entry_idx++) {
		if (IS_IHST(_imjhst_history[entry_idx].pronun, _imjhst_history[entry_idx].conversion)) {
			if (histories >= hist_idx) {
				utf8strlcpy(history, buf_len, _imjhst_history[entry_idx].pronun);
flf_d_printf("==> [%s]\n", history);
				return strlen(history);
			}
			histories++;
		}
	}
flf_d_printf("==> []\n");
	return 0;
}
PRIVATE int imjihst_insert_newest(const char *pronun)
{
flf_d_printf("[%s]\n", pronun);
//	if (utf8s_chars(pronun, INT_MAX) > 5)
//		return 0;
	return imjhst_insert_newest(pronun, "");
}
//-----------------------------------------------------------------------------

PRIVATE int imjchst_insert_newest(const char *pronun, const char *conversion)
{
flf_d_printf("[%s]:[%s]\n", pronun, conversion);
	return imjhst_insert_newest(pronun, conversion);
}
PRIVATE int imjchst_get_matches(char *pronun, int len_to_match)
{
	int entry_idx;
	int matches;

	matches = 0;
	for (entry_idx = 0; entry_idx < _imjhst_history_entries; entry_idx++) {
		entry_idx = imjhst_search_exact_match(entry_idx, pronun, len_to_match, "*");
		if (entry_idx < 0)
			break;
		if (entry_idx >= 0) {
			matches++;
		}
	}
flf_d_printf("imjchst_get_matches([%s]:%d) ==> %d\n", pronun, len_to_match, matches);
	return matches;
}
PRIVATE int imjchst_get_nth_match(int match_idx, char *pronun, int len_to_match,
 char *conversion, int buf_len)
{
	int entry_idx;
	int matches;

flf_d_printf("imjchst_get_nth_match(%d, [%s]:%d)\n", match_idx, pronun, len_to_match);
	conversion[0] = '\0';
	matches = 0;
	for (entry_idx = 0; entry_idx < _imjhst_history_entries; entry_idx++) {
		entry_idx = imjhst_search_exact_match(entry_idx, pronun, len_to_match, "*");
		if (entry_idx < 0)
			break;
		if (entry_idx >= 0) {
			if (matches >= match_idx) {
				utf8strlcpy(conversion, buf_len, _imjhst_history[entry_idx].conversion);
flf_d_printf("==> [%s]\n", conversion);
				return strlen(conversion);
			}
			matches++;
		}
	}
flf_d_printf("==> []\n");
	return 0;
}
PRIVATE int imjchst_search_longest_match(char *pronun)
{
	int max_match_len;
	int entry_idx;
	int len;

flf_d_printf("[%s]\n", pronun);
	max_match_len = 0;
	if (strlen(pronun) == 0)
		return max_match_len;
	for (entry_idx = 0; entry_idx < _imjhst_history_entries; entry_idx++) {
		if (IS_CHST(_imjhst_history[entry_idx].pronun, _imjhst_history[entry_idx].conversion)) {
			len = strlen(_imjhst_history[entry_idx].pronun);
			if (strncmp(_imjhst_history[entry_idx].pronun, pronun, len) == 0) {
				if (len > max_match_len) {
					max_match_len = len;
				}
			}
		}
	}
flf_d_printf("[%s] ==> %d\n", pronun, max_match_len);
	return max_match_len;
}
//-----------------------------------------------------------------------------

PRIVATE int imjhst_clear_all(void)
{
	return _imjhst_history_entries = 0;
}
PRIVATE int imjhst_get_entries(void)
{
	return _imjhst_history_entries;
}
PRIVATE int imjhst_is_updated(void)
{
	return _imjhst_history_updated;
}
PRIVATE int imjhst_set_updated(void)
{
	return _imjhst_history_updated = 1;
}
PRIVATE int imjhst_clear_updated(void)
{
	return _imjhst_history_updated = 0;
}
PRIVATE int imjhst_append_entry(char *pronun, char *conversion)
{
//flf_d_printf("imjhst_append_entry([%s], [%s])\n", pronun, conversion);
	if (strlen(pronun) == 0)
		return 0;
	if (_imjhst_history_entries < MAX_CONVERSION_HISTORIES) {
		imjhst_put_entry(_imjhst_history_entries, pronun, conversion);
		_imjhst_history_entries = _MIN(_imjhst_history_entries+1,
		 MAX_CONVERSION_HISTORIES);
	}
//flf_d_printf("_imjhst_history_entries: %d\n", _imjhst_history_entries);
	return _imjhst_history_entries;
}
PRIVATE int imjhst_insert_newest(const char *pronun, const char *conversion)
{
	int entry_idx;

flf_d_printf("[%s], [%s]\n", pronun, conversion);
	if (strcmp(pronun, conversion) == 0 && utf8s_chars(pronun, INT_MAX) > 5)
		return 0;
	entry_idx = imjhst_is_there_the_same_entry(0, pronun, conversion);
	if (entry_idx > 0)	// if the same entry found, delete it.
		imjhst_delete_entry(entry_idx);
	if (entry_idx != 0) {
		imjhst_shift_older();
		_imjhst_history_entries = _MIN(_imjhst_history_entries+1,
		 MAX_CONVERSION_HISTORIES);
		imjhst_put_entry(0, pronun, conversion);
	}
	imjhst_set_updated();
flf_d_printf("_imjhst_history_entries: %d\n", _imjhst_history_entries);
///imjhst_save(NULL);
	return _imjhst_history_entries;
}
PRIVATE void imjhst_shift_older(void)
{
	int last_entry_idx;		// last entry index to be moved

	if (_imjhst_history_entries) {
//	+--------+ <== 0
//	| str-00 | <-- entry to be freed
//	+--------+ <== 1
//	| str-01 |
//	+--------+
//	| str-02 |
//	+--------+
//	| str-03 |
//	+--------+
//	| str-04 |
//	+--------+
//	| str-05 |
//	+--------+
//	| str-06 |
//	+--------+ <== last_entry_idx
//	|        |
//	+--------+
		last_entry_idx = _MIN(_imjhst_history_entries-1,
		 MAX_CONVERSION_HISTORIES-1);
		// shift all entries to 1 older (the oldest entry disappears)
		memmove(&_imjhst_history[1], &_imjhst_history[0], 
		 (char *)&_imjhst_history[last_entry_idx]
		  - (char *)&_imjhst_history[0]);
	}
}
PRIVATE int imjhst_delete_entry(int entry_idx)
{
	int last_entry_idx;		// (last entry index to be moved)+1

	if (entry_idx < _imjhst_history_entries) {
//	+--------+
//	| str-00 |
//	+--------+ <== entry_idx
//	| str-01 | <-- entry to be deleted
//	+--------+ <== entry_idx+1
//	| str-02 |
//	+--------+
//	| str-03 |
//	+--------+
//	| str-04 |
//	+--------+
//	| str-05 |
//	+--------+
//	| str-06 |
//	+--------+ <== _imjhst_history_entries
//	|        |
//	+--------+
		last_entry_idx = _MIN(_imjhst_history_entries,
		 MAX_CONVERSION_HISTORIES);
		// shift all entries to 1 newer (1 entry disappears)
		memmove(&_imjhst_history[entry_idx], &_imjhst_history[entry_idx+1],
		 (char *)&_imjhst_history[last_entry_idx]
		  - (char *)&_imjhst_history[entry_idx+1]);
		_imjhst_history_entries = _MAX(0, _imjhst_history_entries--);
	}
	return entry_idx;
}
PRIVATE int imjhst_is_there_the_same_entry(int start_entry_idx,
 const char *pronun, const char *conversion)
{
	int entry_idx;

_FLF_
flf_d_printf("%d, [%s], [%s]\n", start_entry_idx, pronun, conversion);
	for (entry_idx = start_entry_idx; entry_idx < _imjhst_history_entries; entry_idx++) {
		entry_idx = imjhst_search_exact_match(entry_idx, pronun, strlen(pronun), conversion);
		if (entry_idx < 0)
			break;
		if (entry_idx >= 0) {
			if (strcmp(_imjhst_history[entry_idx].conversion, conversion) == 0) {
_FL_
				return entry_idx;
			}
		}
	}
_FL_
	return -1;
}
PRIVATE int imjhst_search_exact_match(int start_entry_idx,
 const char *pronun, int len_to_match, const char *conversion)
{
	int entry_idx;

	len_to_match = _MIN(MAX_HISTORY_PRONUN_LEN, len_to_match);
	if (strlen(pronun) == 0 || len_to_match == 0)
		return -1;
	for (entry_idx = start_entry_idx; entry_idx < _imjhst_history_entries; entry_idx++) {
		if ((conversion[0] == '\0'
		 ? IS_IHST(_imjhst_history[entry_idx].pronun, _imjhst_history[entry_idx].conversion)
		 : IS_CHST(_imjhst_history[entry_idx].pronun, _imjhst_history[entry_idx].conversion))
		 && (int)strlen(_imjhst_history[entry_idx].pronun) == len_to_match
		 && strncmp(_imjhst_history[entry_idx].pronun, pronun, len_to_match) == 0) {
			return entry_idx;
		}
	}
	return -1;
}
PRIVATE int imjhst_get_entry(int entry_idx, char *pronun, char *conversion)
{
	pronun[0] = '\0';
	conversion[0] = '\0';
	if (entry_idx < MAX_CONVERSION_HISTORIES) {
		utf8strlcpy(pronun, MAX_HISTORY_PRONUN_LEN,
		 _imjhst_history[entry_idx].pronun);
		utf8strlcpy(conversion, MAX_HISTORY_CONVERTED_LEN,
		 _imjhst_history[entry_idx].conversion);
//flf_d_printf("%d, [%s], [%s]\n", entry_idx, pronun, conversion);
	}
	return entry_idx;
}
PRIVATE int imjhst_put_entry(int entry_idx, const char *pronun, const char *conversion)
{
///flf_d_printf("%d, [%s], [%s]\n", entry_idx, pronun, conversion);
	if (entry_idx < MAX_CONVERSION_HISTORIES) {
		utf8strlcpy(_imjhst_history[entry_idx].pronun, MAX_HISTORY_PRONUN_LEN,
		 pronun);
		utf8strlcpy(_imjhst_history[entry_idx].conversion, MAX_HISTORY_CONVERTED_LEN,
		 conversion);
	}
	return entry_idx;
}
//-----------------------------------------------------------------------------
//imjcandid_...

PRIVATE candidates_t candidate_list;
PRIVATE int imjcandid_clear_candids(void)
{
	int candid_idx;

_FLF_
	for (candid_idx = 0; candid_idx < MAX_CANDIDS_LIST; candid_idx++) {
		candidate_list[candid_idx].pronun_len = 0;
		candidate_list[candid_idx].candidate[0] = '\0';
	}
	return 0;
}
PRIVATE int imjcandid_get_num_of_candids(void)
{
	int candid_idx;

	for (candid_idx = 0; candid_idx < MAX_CANDIDS_LIST; candid_idx++) {
		if (candidate_list[candid_idx].pronun_len == 0)
			break;
	}
	return candid_idx;
}
PRIVATE int imjcandid_append_one_candid(char *candid)
{
	int candid_idx;
	int len = utf8s_len_le(candid, MAX_CANDID_LEN);

flf_d_printf("[%s]\n", candid);
#if 1
	if (imjcandid_is_there_the_same_candid(candid) < 0) {
		candid_idx = imjcandid_get_num_of_candids();
		if (candid_idx < MAX_CANDIDS_LIST) {
			imjcandid_put_candid(candid_idx, candid, len);
		}
	}
#else
	if ((candid_idx = imjcandid_is_there_the_same_candid(candid)) >= 0) {
		imjcandid_delete_one_candid(candid_idx);
	}
	candid_idx = imjcandid_get_num_of_candids();
	if (candid_idx < MAX_CANDIDS_LIST) {
		imjcandid_put_candid(candid_idx, candid, len);
	}
#endif
imjcandid_dump_candids();
	return imjcandid_get_num_of_candids();
}
PRIVATE int imjcandid_insert_one_candid(char *candid)
{
	int candid_idx;
	int len = utf8s_len_le(candid, MAX_CANDID_LEN);

flf_d_printf("[%s]\n", candid);
	if ((candid_idx = imjcandid_is_there_the_same_candid(candid)) >= 0) {
		imjcandid_delete_one_candid(candid_idx);
	}
	candid_idx = imjcandid_get_num_of_candids();
	if (candid_idx < MAX_CANDIDS_LIST) {
		memmove(&candidate_list[1], &candidate_list[0],
		 sizeof(candidate_list[0]) * candid_idx);
		imjcandid_put_candid(0, candid, len);
	}
	return imjcandid_get_num_of_candids();
}
PRIVATE int imjcandid_is_there_the_same_candid(char *candid)
{
	int candid_idx;

	for (candid_idx = 0; candid_idx < MAX_CANDIDS_LIST; candid_idx++) {
		if (candidate_list[candid_idx].pronun_len == 0)
			break;
		if (imjcandid_compare_candid(candid_idx, candid) == 0)
			return candid_idx;
	}
	return -1;
}
PRIVATE int imjcandid_delete_one_candid(int candid_idx)
{
//_FLF_
//flf_d_printf("%d\n", candid_idx);
	memmove(&candidate_list[candid_idx], &candidate_list[candid_idx+1],
	 sizeof(candidate_list[candid_idx]) * (MAX_CANDIDS_LIST-candid_idx-1));
	candidate_list[MAX_CANDIDS_LIST-1].pronun_len = 0;
	candidate_list[MAX_CANDIDS_LIST-1].candidate[0] = '\0';
	return 0;
}
PRIVATE int imjcandid_compare_candid(int candid_idx, char *candid)
{
	int len = utf8s_len_le(candid, MAX_CANDID_LEN);
	int diff;

	diff = candidate_list[candid_idx].pronun_len - len;
	return diff == 0 ? strncmp(candidate_list[candid_idx].candidate, candid, len) : diff;
}
PRIVATE int imjcandid_put_candid(int candid_idx, char *candid, int len)
{
	candidate_list[candid_idx].pronun_len = len;
	utf8strlcpy(candidate_list[candid_idx].candidate, len, candid);
	return 0;
}
PRIVATE int imjcandid_get_candid(int candid_idx, char *buf, int buf_len)
{
	utf8strlcpy(buf, buf_len, candidate_list[candid_idx].candidate);
	return candidate_list[candid_idx].pronun_len;
}
PRIVATE int imjcandid_dump_candids(void)
{
	int candid_idx;

	for (candid_idx = 0; candid_idx < MAX_CANDIDS_LIST; candid_idx++) {
		if (candidate_list[candid_idx].pronun_len == 0)
			break;
flf_d_printf("%d:%2d[%s]\n", candid_idx,
 candidate_list[candid_idx].pronun_len, candidate_list[candid_idx].candidate);
	}
	return candid_idx;
}

// ローマ字入力 ---------------------------------------------------------------
//imjatoh

#define	MAX_ROM_ALPHA_LEN	(4)
#define	MAX_ROM_HIRA_LEN	(3*5)
#define	MAX_ROM_TABLE_LINE_LEN	(MAX_ROM_ALPHA_LEN+1+MAX_ROM_HIRA_LEN)
#define	MAX_ROM_TABLE_LINES		1000

PRIVATE int atoh_convert_one(const char *romaji, char *hira, int buf_len);
PRIVATE int atoh_convert_one2(const char *romaji, char *hira, int buf_len);
PRIVATE int atoh_convert_one3(const char *romaji, char *hira);
PRIVATE int atoh_reverse_one(char *hira, char *romaji);
PRIVATE int atoh_reverse_one2(char *hira, char *romaji);

char roman_table[MAX_ROM_TABLE_LINES+1][MAX_ROM_TABLE_LINE_LEN+1] = {
	"     　",	// " " ==> "　"
	"-    ー",
	"/    ／",
	"[    「",
	"]    」",
	",    、",
	".    。",
	"a    あ",
	"ba   ば",
	"be   べ",
	"bi   び",
	"bo   ぼ",
	"bu   ぶ",
	"bya  びゃ",
	"bye  びぇ",
	"byi  びぃ",
	"byo  びょ",
	"byu  びゅ",
	"ca  か",
	"ce  せ",
	"ci  し",
	"co  こ",
	"cu  きゅ",
	"cha  ちゃ",
	"che  ちぇ",
	"chi  ち",
	"cho  ちょ",
	"chu  ちゅ",
	"cya  ちゃ",
	"cye  ちぇ",
	"cyi  ちぃ",
	"cyo  ちょ",
	"cyu  ちゅ",
	"da   だ",
	"de   で",
	"dha  でゃ",
	"dhe  でぇ",
	"dhi  でぃ",
	"dho  でょ",
	"dhu  でゅ",
	"di   ぢ",
	"do   ど",
	"du   づ",
	"dwu  どぅ",
	"dya  ぢゃ",
	"dye  ぢぇ",
	"dyi  ぢぃ",
	"dyo  ぢょ",
	"dyu  ぢゅ",
	"e    え",
	"fa   ふぁ",
	"fe   ふぇ",
	"fi   ふぃ",
	"fo   ふぉ",
	"fu   ふ",
	"fya  ふゃ",
	"fye  ふぇ",
	"fyi  ふぃ",
	"fyo  ふょ",
	"fyu  ふゅ",
	"ga   が",
	"ge   げ",
	"gi   ぎ",
	"go   ご",
	"gu   ぐ",
	"gwa  ぐぁ",
	"gya  ぎゃ",
	"gye  ぎぇ",
	"gyi  ぎぃ",
	"gyo  ぎょ",
	"gyu  ぎゅ",
	"ha   は",
	"he   へ",
	"hi   ひ",
	"ho   ほ",
	"hu   ふ",
	"hya  ひゃ",
	"hye  ひぇ",
	"hyi  ひぃ",
	"hyo  ひょ",
	"hyu  ひゅ",
	"i    い",
	"ja   じゃ",
	"je   じぇ",
	"ji   じ",
	"jo   じょ",
	"ju   じゅ",
	"jya  じゃ",
	"jye  じぇ",
	"jyi  じぃ",
	"jyo  じょ",
	"jyu  じゅ",
	"ka   か",
	"ke   け",
	"ki   き",
	"ko   こ",
	"ku   く",
	"kwa  くぁ",
	"kya  きゃ",
	"kye  きぇ",
	"kyi  きぃ",
	"kyo  きょ",
	"kyu  きゅ",
	"la   ぁ",
	"le   ぇ",
	"li   ぃ",
	"lka  ヵ",
	"lke  ヶ",
	"lo   ぉ",
	"ltsu っ",
	"ltu  っ",
	"lu   ぅ",
	"lwa  ゎ",
	"lya  ゃ",
	"lye  ぇ",
	"lyi  ぃ",
	"lyo  ょ",
	"lyu  ゅ",
	"ma   ま",
	"me   め",
	"mi   み",
	"mo   も",
	"mu   む",
	"mya  みゃ",
	"mye  みぇ",
	"myi  みぃ",
	"myo  みょ",
	"myu  みゅ",
	"nn   ん",
	"na   な",
	"ne   ね",
	"ni   に",
	"no   の",
	"nu   ぬ",
	"n    ん",
	"n'   ん",
	"nya  にゃ",
	"nye  にぇ",
	"nyi  にぃ",
	"nyo  にょ",
	"nyu  にゅ",
	"o    お",
	"pa   ぱ",
	"pe   ぺ",
	"pi   ぴ",
	"po   ぽ",
	"pu   ぷ",
	"pya  ぴゃ",
	"pye  ぴぇ",
	"pyi  ぴぃ",
	"pyo  ぴょ",
	"pyu  ぴゅ",
	"ra   ら",
	"re   れ",
	"ri   り",
	"ro   ろ",
	"ru   る",
	"rya  りゃ",
	"rye  りぇ",
	"ryi  りぃ",
	"ryo  りょ",
	"ryu  りゅ",
	"sa   さ",
	"se   せ",
	"sha  しゃ",
	"she  しぇ",
	"shi  し",
	"sho  しょ",
	"shu  しゅ",
	"si   し",
	"so   そ",
	"su   す",
	"sya  しゃ",
	"sye  しぇ",
	"syi  しぃ",
	"syo  しょ",
	"syu  しゅ",
	"ta   た",
	"te   て",
	"tha  てゃ",
	"the  てぇ",
	"thi  てぃ",
	"tho  てょ",
	"thu  てゅ",
	"ti   ち",
	"to   と",
	"tsa  つぁ",
	"tse  つぇ",
	"tsi  つぃ",
	"tso  つぉ",
	"tsu  つ",
	"tu   つ",
	"twu  とぅ",
	"tya  ちゃ",
	"tye  ちぇ",
	"tyi  ちぃ",
	"tyo  ちょ",
	"tyu  ちゅ",
	"u    う",
	"va   う゛ぁ",
	"ve   う゛ぇ",
	"vi   う゛ぃ",
	"vo   う゛ぉ",
	"vu   う゛",
	"wa   わ",
	"we   うぇ",
	"wi   うぃ",
	"wo   を",
	"wu   う",
	"wye  ゑ",
	"wyi  ゐ",
	"x\"   ゛",
	"x@   ゜",
	"xa   ぁ",
	"xe   ぇ",
	"xi   ぃ",
	"xka  ヵ",
	"xke  ヶ",
	"xo   ぉ",
	"xtsu っ",
	"xtu  っ",
	"xu   ぅ",
	"xwa  ゎ",
	"xya  ゃ",
	"xye  ぇ",
	"xyi  ぃ",
	"xyo  ょ",
	"xyu  ゅ",
	"ya   や",
	"ye   いぇ",
	"yi   い",
	"yo   よ",
	"yu   ゆ",
	"za   ざ",
	"ze   ぜ",
	"zi   じ",
	"zo   ぞ",
	"zu   ず",
	"zya  じゃ",
	"zye  じぇ",
	"zyi  じぃ",
	"zyo  じょ",
	"zyu  じゅ",
};

void test_atoh_functions(void)
{
	char pronun[IM_INPUT_LINE_LEN+1];
	char roman1[] = "hiragana";
	char hira1[] = "ひらがな";
	char roman2[] = "kanji";
	int off;

_FLF_
	atoh_convert_line("hiragana", pronun, IM_INPUT_LINE_LEN);
flf_d_printf("roman1:[%s] ==> pronun[%s]\n", roman1, pronun);
	off = atoh_romaji_offset(roman1, strlen("ひら"));
flf_d_printf("atoh_romaji_offset([%s], strlen([ひら])) ==> %d\n",
 roman1, off);
	off = atoh_romaji_offset(roman2, strlen("かん"));
flf_d_printf("atoh_romaji_offset([%s], strlen([かん])) ==> %d\n",
 roman2, off);
	off = atoh_hira_offset(roman1, hira1, 6);
flf_d_printf("atoh_hira_offset([%s], [%s], 6) ==> %d\n",
 roman1, hira1, off);
}

#if 0
int atoh_load_table(char *file_path)
{
	FILE *fp = NULL;
	int idx;
	char buffer[MAX_ROM_TABLE_LINE_LEN+10+1];

	if (file_path == NULL)
		file_path = ROM_FILE_NAME;
	if ((fp = fopen(file_path, "r")) == NULL) {
		_ERR_
		return 1;
	}
	for (idx = 0 ; idx < MAX_ROM_TABLE_LINES; idx++) {
		if (fgets(buffer, MAX_ROM_TABLE_LINE_LEN+10, fp) == NULL) {
			break;
		}
		cut_line_tail_crlf(buffer);
		utf8strlcpy(roman_table[idx], MAX_ROM_TABLE_LINE_LEN, buffer);
	}
	roman_table[idx][0] = '\0';		// end of lines
	if (fclose(fp) < 0) {
		_FL_
	}
	fp = NULL;
	return 0;
}
#endif

int atoh_hira_offset(char *romaji, char *hira, int offset_r)
{
	char *ptr_a;
	int offset_h;
	char buf_h_from_a[IM_INPUT_LINE_LEN+1];
	int len_a;
	int len_h;

//_FLF_
	len_h = strlen(hira);
	ptr_a = romaji;
	offset_h = 0;
	for ( ; *ptr_a; ) {
		if (offset_h >= len_h)
			break;
		if (ptr_a - romaji >= offset_r)
			break;
		len_a = atoh_convert_one(ptr_a, buf_h_from_a, IM_INPUT_LINE_LEN);
		ptr_a += len_a;
		offset_h += strlen(buf_h_from_a);
	}
//flf_d_printf("romaji:[%s],%d ==> %d\r\n", romaji, offset_r, offset_h);
	return offset_h;
}
int atoh_romaji_offset(char *romaji, int offset_h)
{
	char *ptr_a;
	int off_h;
	char buf_h_from_a[IM_INPUT_LINE_LEN+1];
	int len_a;

//_FLF_
	ptr_a = romaji;
	off_h = 0;
	for ( ; *ptr_a; ) {
		if (off_h >= offset_h)
			break;
		len_a = atoh_convert_one(ptr_a, buf_h_from_a, IM_INPUT_LINE_LEN);
		ptr_a += len_a;
		off_h += strlen(buf_h_from_a);
	}
//flf_d_printf("romaji:[%s],%d ==> %d\r\n", romaji, offset_h, ptr_a - romaji);
	return ptr_a - romaji;
}

// romaji     insert
// ---------- --------------
// macchinngu まっ{ち}んぐ   ==> まっ|んぐ  -> maxtsunngu
// ochaya     おち{ゃ}や     ==> おち|や    -> ochiya
// ivennto    いう゛{ぇ}んと ==> いう゛んと -> ivunnto
// ivennto    いう{゛}ぇんと ==> いうぇんと -> iuxennto
// ivennto    い{う}゛ぇんと ==> い゛ぇんと -> ix"xennto
// abcdi      あbc{d}い       ==> あbcい      -> abci
// abcdi      あb{c}dい       ==> あbdい      -> abdi
// abcdi      あ{b}cdい       ==> あcdい      -> acdi
int atoh_insert_romaji_chars(char *romaji, int max_romaji_len,
 char *hira, int off_h, char *insert)
{
	int off_r;
	char buffer_r[IM_INPUT_LINE_LEN+1];

//_FLF_
//flf_d_printf("romaji:[%s]<==[%s]\n", romaji, insert);
//flf_d_printf("hira:[%s]:%d\n", hira, off_h);
	atoh_split_romaji_spelling(romaji, max_romaji_len, hira, off_h);
//_FL_
	off_r = atoh_romaji_offset(romaji, off_h);
	strlncpy(buffer_r, IM_INPUT_LINE_LEN, romaji, off_r);
	utf8strlcat(buffer_r, IM_INPUT_LINE_LEN, insert);
	utf8strlcat(buffer_r, IM_INPUT_LINE_LEN, &romaji[off_r]);
	utf8strlcpy(romaji, IM_INPUT_LINE_LEN, buffer_r);
//flf_d_printf("romaji:[%s]\n", romaji);
	return strlen(romaji);
}

// romaji     hira
// ---------- --------------
// macchinngu まっ{ち}んぐ   ==> まっ|んぐ  -> maxtsunngu
// ochaya     おち{ゃ}や     ==> おち|や    -> ochiya
// ivennto    いう゛{ぇ}んと ==> いう゛んと -> ivunnto
// ivennto    いう{゛}ぇんと ==> いうぇんと -> iuxennto
// ivennto    い{う}゛ぇんと ==> い゛ぇんと -> ix"xennto
// abcdi      あbc{d}い       ==> あbcい      -> abci
// abcdi      あb{c}dい       ==> あbdい      -> abdi
// abcdi      あ{b}cdい       ==> あcdい      -> acdi

//      +----- off_h_from
//      |  +-- off_h_to
//      |  |
// i  ve       nnto
// い う{゛}ぇ ん と
// い う    ぇ ん と
// i  u     xe nn to
int atoh_delete_pronun_chars(char *romaji, int max_romaji_len,
 char *hira, int off_h_from, int off_h_to)
{
	int off_r_from;
	int off_r_to;

_FLFE_
	atoh_split_romaji_spelling(romaji, max_romaji_len, hira, off_h_from);
	atoh_split_romaji_spelling(romaji, max_romaji_len, hira, off_h_to);
	off_r_from = atoh_romaji_offset(romaji, off_h_from);
	off_r_to = atoh_romaji_offset(romaji, off_h_to);
	strcpy(&romaji[off_r_from], &romaji[off_r_to]);
	strcpy(&hira[off_h_from], &hira[off_h_to]);
//flf_d_printf("romaji:[%s]\r\n", romaji);
//flf_d_printf("hira:[%s]\r\n", hira);
_FLFL_
	return strlen(hira);
}
//      +----- split_offset
//      |
//      |
// sa kka   -
// さ っ か ー
//   |     |
//   |     +-- off_h_to
//   +-------- off_h_from
// さ っ か ー
// sa ltuka -
int atoh_split_romaji_spelling(char *romaji, int max_romaji_len,
 char *hira, int split_offset)
{
	char *ptr_a;
	char *ptr_h;
	char buf_h_from_a[IM_INPUT_LINE_LEN+1];
	char *ptr_htoa;
	char buf_a_from_h[MAX_ROM_HIRA_LEN+1];
	char buffer_a_from_h[IM_INPUT_LINE_LEN+1];
	int off_h_from;		// offset of the begining of spelling
	int off_h_to;			// offset of the end of spelling
	int len_a;
	int len_h;
	char buffer_r[IM_INPUT_LINE_LEN+1];

//flf_d_printf("romaji:[%s]\n", romaji);
//flf_d_printf("hira:[%s],[%s]\n", hira, &hira[split_offset]);
	ptr_a = romaji;
	ptr_h = hira;
	for ( ; *ptr_a; ) {
		len_a = atoh_convert_one(ptr_a, buf_h_from_a, IM_INPUT_LINE_LEN);
		off_h_from = ptr_h - hira;
		off_h_to = off_h_from + strlen(buf_h_from_a);
		if (off_h_from < split_offset && split_offset < off_h_to) {
//flf_d_printf("off_h_from:%d split_off:%d off_h_to:%d\r\n",
// off_h_from, split_offset, off_h_to);
			buffer_a_from_h[0] = '\0';
			for (ptr_htoa = ptr_h; ptr_htoa < &ptr_h[strlen(buf_h_from_a)]; ) {
//flf_d_printf("ptr_htoa:[%s]\n", ptr_htoa);
				len_h = atoh_reverse_one(ptr_htoa, buf_a_from_h);
				utf8strlcat(buffer_a_from_h, MAX_ROM_HIRA_LEN, buf_a_from_h);
				ptr_htoa += len_h;
			}
			strlncpy(buffer_r, IM_INPUT_LINE_LEN, romaji, ptr_a - romaji);
			utf8strlcat(buffer_r, IM_INPUT_LINE_LEN, buffer_a_from_h);
			utf8strlcat(buffer_r, IM_INPUT_LINE_LEN, ptr_a + len_a);
			strlcpy(romaji, buffer_r, max_romaji_len);
			break;
		}
		ptr_a += len_a;
		ptr_h += strlen(buf_h_from_a);
	}
	return strlen(hira);
}
int atoh_convert_line(const char *romaji, char *hira, int buf_len)
{
	const char *ptr_a;
	char buf_h[IM_INPUT_LINE_LEN+1];
	int len_a;

//_FLF_
//flf_d_printf("romaji:[%s]==>\r\n", romaji);
	hira[0] = '\0';
	for (ptr_a = romaji; *ptr_a; ) {
		len_a = atoh_convert_one(ptr_a, buf_h, IM_INPUT_LINE_LEN);
		utf8strlcat(hira, buf_len, buf_h);
		ptr_a += len_a;
	}
//flf_d_printf("hira:[%s]\r\n", hira);
	return strlen(hira);
}
PRIVATE int atoh_convert_one(const char *romaji, char *hira, int buf_len)
{
	int len_a;

//_FLF_
//flf_d_printf(" romaji:[%s]==>\r\n", romaji);
	if (*romaji == IM_UNVIS_SEP) {
		hira[0] = '\0';
		len_a = utf8c_bytes(romaji);		// length of unconverted char
	} else {
		len_a = atoh_convert_one2(romaji, hira, buf_len);
		if (len_a == 0) {
			len_a = utf8c_bytes(romaji);	// copy unconverted char
			strlcpy(hira, romaji, len_a);
		}
	}
//flf_d_printf(" hira:[%s]\r\n", hira);
	return len_a;
}
PRIVATE int atoh_convert_one2(const char *romaji, char *hira, int buf_len)
{
	const char *ptr_a;
	int len_a;
	char buf_h[MAX_ROM_HIRA_LEN+1];

	hira[0] = '\0';
	ptr_a = romaji;
	len_a = atoh_convert_one3(ptr_a, hira);
	if (len_a == 0) {
		if (isalpha(ptr_a[0])) {
			for ( ; ptr_a[0] == ptr_a[1]; ptr_a++) {
				utf8strlcat(hira, buf_len, "っ");	// "kkkka" ==> "っっっka"
			}
			len_a = atoh_convert_one3(ptr_a, buf_h);
			if (len_a == 0) {
				len_a = utf8c_bytes(ptr_a);		// copy unconverted char
				utf8strlncat(hira, buf_len, ptr_a, len_a);
			} else {
				utf8strlcat(hira, buf_len, buf_h);	// "kkkka" ==> "っっっか"
			}
			ptr_a += len_a;
			len_a = ptr_a - romaji;
		}
	}
	return len_a;
}
// ka ==> か
PRIVATE int atoh_convert_one3(const char *romaji, char *hira)
{
	int idx;
	char *ptr_h;
	int len_a;
	int match_idx;
	int max_len;

//_FLF_
//flf_d_printf(" romaji:[%s]==>\r\n", romaji);
	match_idx = -1;
	max_len = 0;
	hira[0] = '\0';
	for (idx = 0 ; roman_table[idx][0] && idx < MAX_ROM_TABLE_LINES; idx++) {
		len_a = word_len(roman_table[idx]);
		if (strncmp(romaji, roman_table[idx], len_a) == 0) {
			if (len_a > max_len) {
				match_idx = idx;
				max_len = len_a;
			}
		}
	}
	if (match_idx >= 0) {
		idx = match_idx;
		ptr_h = roman_table[idx] + next_word(roman_table[idx]);
		strcpy(hira, ptr_h);
	}
//flf_d_printf(" hira:[%s]\r\n", hira);
	return max_len;
}
// か ==> ka
PRIVATE int atoh_reverse_one(char *hira, char *romaji)
{
	int len_h;

	len_h = atoh_reverse_one2(hira, romaji);
	if (len_h == 0) {
		len_h = utf8c_bytes(hira);	// copy unconverted char
		strlcpy(romaji, hira, len_h);
	}
	return len_h;
}
PRIVATE int atoh_reverse_one2(char *hira, char *romaji)
{
	int idx;
	char *ptr_h;
	int len_a;
	int len_h;
	int match_idx;
	int max_len;

//_FLF_
//flf_d_printf(" hira:[%s]==>\r\n", hira);
	match_idx = -1;
	max_len = 0;
	len_h = 0;
	romaji[0] = '\0';
	for (idx = 0 ; roman_table[idx][0] && idx < MAX_ROM_TABLE_LINES; idx++) {
//flf_d_printf(" romaji:[%s]\r\n", roman_table[idx]);
		ptr_h = roman_table[idx] + next_word(roman_table[idx]);
		if (strlcmp(hira, ptr_h) == 0) {
			len_a = word_len(roman_table[idx]);
			if (len_a > max_len) {
				match_idx = idx;
				max_len = len_a;
				break;		// not continue "the-longest" search
			}
		}
	}
	if (match_idx >= 0) {
		idx = match_idx;
		ptr_h = roman_table[idx] + next_word(roman_table[idx]);
		len_h = strlen(ptr_h);
		strlcpy(romaji, roman_table[idx], word_len(roman_table[idx]));
	}
//flf_d_printf(" romaji:[%s]\r\n", romaji);
	return len_h;
}

// 全角/半角/ひらがな/カタカナ 相互変換 ---------------------------------------
//imjhira_...

static char hiragana_table[] = 
"　 ／ ， ． ・ ： ； ？ ！ ’ ” ＼ ＾ ‾ ＿ （ ） ｛ ｝ ［ ］ ¥ "
"０ １ ２ ３ ４ ５ ６ ７ ８ ９ ＋ − ＄ ％ ＃ ＆ ＊ ＠ ＝ "
"Ａ Ｂ Ｃ Ｄ Ｅ Ｆ Ｇ Ｈ Ｉ Ｊ Ｋ Ｌ Ｍ Ｎ Ｏ Ｐ Ｑ Ｒ Ｓ Ｔ Ｕ Ｖ Ｗ Ｘ Ｙ Ｚ "
"ａ ｂ ｃ ｄ ｅ ｆ ｇ ｈ ｉ ｊ ｋ ｌ ｍ ｎ ｏ ｐ ｑ ｒ ｓ ｔ ｕ ｖ ｗ ｘ ｙ ｚ "
"が ぎ ぐ げ ご ざ じ ず ぜ ぞ だ ぢ づ で ど ば び ぶ べ ぼ ぱ ぴ ぷ ぺ ぽ う゛ "
"ぁ あ ぃ い ぅ う ぇ え ぉ お か き く け こ "
"さ し す せ そ た ち っ つ て と な に ぬ ね の "
"は ひ ふ へ ほ ま み む め も ゃ や ゅ ゆ ょ よ ら り る れ ろ わ を ん "
"ヮ ヰ ヱ ヵ ヶ "
"゛ ゜ 、 「 」 ー 。 ";

static char katakana_table[] = 
"　 ／ ， ． ・ ： ； ？ ！ ’ ” ＼ ＾ ‾ ＿ （ ） ｛ ｝ ［ ］ ¥ "
"０ １ ２ ３ ４ ５ ６ ７ ８ ９ ＋ − ＄ ％ ＃ ＆ ＊ ＠ ＝ "
"Ａ Ｂ Ｃ Ｄ Ｅ Ｆ Ｇ Ｈ Ｉ Ｊ Ｋ Ｌ Ｍ Ｎ Ｏ Ｐ Ｑ Ｒ Ｓ Ｔ Ｕ Ｖ Ｗ Ｘ Ｙ Ｚ "
"ａ ｂ ｃ ｄ ｅ ｆ ｇ ｈ ｉ ｊ ｋ ｌ ｍ ｎ ｏ ｐ ｑ ｒ ｓ ｔ ｕ ｖ ｗ ｘ ｙ ｚ "
"ガ ギ グ ゲ ゴ ザ ジ ズ ゼ ゾ ダ ヂ ヅ デ ド バ ビ ブ ベ ボ パ ピ プ ペ ポ ヴ "
"ァ ア ィ イ ゥ ウ ェ エ ォ オ カ キ ク ケ コ "
"サ シ ス セ ソ タ チ ッ ツ テ ト ナ ニ ヌ ネ ノ "
"ハ ヒ フ ヘ ホ マ ミ ム メ モ ャ ヤ ュ ユ ョ ヨ ラ リ ル レ ロ ワ ヲ ン "
"ヮ ヰ ヱ ヵ ヶ "
"゛ ゜ 、 「 」 ー 。 ";

static char han_table[] = 
"  / , . ･ : ; ? ! ' \" \\ ^ ~ _ ( ) { } [ ] \\ "
"0 1 2 3 4 5 6 7 8 9 + - $ % # & * @ = "
"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z "
"a b c d e f g h i j k l m n o p q r s t u v w x y z "
"ｶﾞ ｷﾞ ｸﾞ ｹﾞ ｺﾞ ｻﾞ ｼﾞ ｽﾞ ｾﾞ ｿﾞ ﾀﾞ ﾁﾞ ﾂﾞ ﾃﾞ ﾄﾞ ﾊﾞ ﾋﾞ ﾌﾞ ﾍﾞ ﾎﾞ ﾊﾟ ﾋﾟ ﾌﾟ ﾍﾟ ﾎﾟ ｳﾞ "
"ｧ ｱ ｨ ｲ ｩ ｳ ｪ ｴ ｫ ｵ ｶ ｷ ｸ ｹ ｺ "
"ｻ ｼ ｽ ｾ ｿ ﾀ ﾁ ｯ ﾂ ﾃ ﾄ ﾅ ﾆ ﾇ ﾈ ﾉ "
"ﾊ ﾋ ﾌ ﾍ ﾎ ﾏ ﾐ ﾑ ﾒ ﾓ ｬ ﾔ ｭ ﾕ ｮ ﾖ ﾗ ﾘ ﾙ ﾚ ﾛ ﾜ ｦ ﾝ "
"ヮ ヰ ヱ ヵ ヶ "
"ﾞ ﾟ ､ ｢ ｣ ｰ ｡ ";

int test_hira_kata_han_conversion(void)
{
	char buffer[MAX_DIC_LINE_LEN+1];

	imjhira_to_hira(hiragana_table, buffer, MAX_DIC_LINE_LEN);
	imjhira_to_hira(katakana_table, buffer, MAX_DIC_LINE_LEN);
flf_d_printf("\r\n<[%s]\r\n>[%s]\r\n", katakana_table, buffer);
	imjhira_to_hira(han_table, buffer, MAX_DIC_LINE_LEN);
flf_d_printf("\r\n<[%s]\r\n>[%s]\r\n", han_table, buffer);

	imjhira_to_kata(hiragana_table, buffer, MAX_DIC_LINE_LEN);
flf_d_printf("\r\n<[%s]\r\n>[%s]\r\n", hiragana_table, buffer);
	imjhira_to_kata(katakana_table, buffer, MAX_DIC_LINE_LEN);
	imjhira_to_kata(han_table, buffer, MAX_DIC_LINE_LEN);
flf_d_printf("\r\n<[%s]\r\n>[%s]\r\n", han_table, buffer);

	imjhira_to_han_kata(hiragana_table, buffer, MAX_DIC_LINE_LEN);
flf_d_printf("\r\n<[%s]\r\n>[%s]\r\n", hiragana_table, buffer);
	imjhira_to_han_kata(katakana_table, buffer, MAX_DIC_LINE_LEN);
flf_d_printf("\r\n<[%s]\r\n>[%s]\r\n", katakana_table, buffer);
	imjhira_to_han_kata(han_table, buffer, MAX_DIC_LINE_LEN);
	return 0;
}

// カタ ==> かた
// ｶﾀ   ==> かた
int imjhira_to_hira(const char *str, char *buf, int buf_len)
{
	char buffer[MAX_DIC_LINE_LEN+1];

	imjhira_han_to_zen(str, buffer, MAX_DIC_LINE_LEN);
	return imjhira_kata_to_hira(buffer, buf, buf_len);
}
// かた ==> カタ
// ｶﾀ   ==> カタ
int imjhira_to_kata(const char *str, char *buf, int buf_len)
{
	char buffer[MAX_DIC_LINE_LEN+1];

	imjhira_han_to_zen(str, buffer, MAX_DIC_LINE_LEN);
	return imjhira_hira_to_kata(buffer, buf, buf_len);
}
// かた ==> ｶﾀ
// カタ ==> ｶﾀ
int imjhira_to_han_kata(const char *str, char *buf, int buf_len)
{
	char buffer[MAX_DIC_LINE_LEN+1];

	imjhira_kata_to_hira(str, buffer, MAX_DIC_LINE_LEN);
	return imjhira_zen_to_han(buffer, buf, buf_len);
}

int imjhira_zen_to_han(const char *str, char *buf, int buf_len)
{
	return imjhira_conv_hira_kata_han(str, buf, buf_len,
	 hiragana_table, han_table);
}
int imjhira_han_to_zen(const char *str, char *buf, int buf_len)
{
	return imjhira_conv_hira_kata_han(str, buf, buf_len,
	 han_table, hiragana_table);
}
int imjhira_hira_to_kata(const char *str, char *buf, int buf_len)
{
	return imjhira_conv_hira_kata_han(str, buf, buf_len,
	 hiragana_table, katakana_table);
}
int imjhira_kata_to_hira(const char *str, char *buf, int buf_len)
{
	return imjhira_conv_hira_kata_han(str, buf, buf_len,
	 katakana_table, hiragana_table);
}

PRIVATE int imjhira_conv_hira_kata_han(const char *str, char *buf, int buf_len,
 const char *table_from, const char *table_to)
{
	const char *ptr_str;
	const char *ptr_from;
	const char *ptr_to;

//flf_d_printf("imjhira_conv_hira_kata_han\r\nF[%s]\r\n", str);
//flf_d_printf("TF[%s]\r\nTT[%s]\r\n", table_from, table_to);
	buf[0] = '\0';
	for (ptr_str = str; *ptr_str; ) {
		for (ptr_from = table_from, ptr_to = table_to; *ptr_from; ) {
//flf_d_printf("F:[%s]\r\nT:[%s]\r\n", ptr_from, ptr_to);
			if (strncmp(ptr_str, ptr_from, word_len(ptr_from)) == 0) {
				break;
			}
			ptr_from += next_word(ptr_from);
			ptr_to += next_word(ptr_to);
		}
		if (*ptr_from) {
			// convert
			utf8strlncat(buf, buf_len, ptr_to, word_len(ptr_to));
			ptr_str += word_len(ptr_from);
		} else {
			if (*ptr_str != IM_UNVIS_SEP) {
				// copy
				utf8strlncat(buf, buf_len, ptr_str, utf8c_bytes(ptr_str));
			}
			ptr_str += utf8c_bytes(ptr_str);
		}
	}
//flf_d_printf("[%s]\r\n==>\r\n[%s]\r\n", str, buf);
	return 0;
}

//-----------------------------------------------------------------------------
//imjutil

int strmatchlen_utf8(const char *str1, const char *str2, int max_len)
{
	int match_len;
	int utf8_len;

	utf8_len = 0;
	if ((match_len = strmatchlen(str1, str2, max_len)) > 0) {
		utf8_len = utf8s_len_le(str1, match_len);
	}
//flf_d_printf("strmatchlen_utf8: %d:[%s]:[%s]\n", utf8_len, str1, str2);
	return utf8_len;
}
int strmatchlen(const char *str1, const char *str2, int max_len)
{
	const char *ptr1, *ptr2;
	int match_len;

	ptr1 = str1;
	ptr2 = str2;
//flf_d_printf("[%s] ?? [%s]\n", ptr1, ptr2);
	for (match_len = 0; match_len < max_len; match_len++) {
		if (*ptr1 != *ptr2)
			break;
		ptr1++;
		ptr2++;
	}
//flf_d_printf("match_len: %d\n", match_len);
	return match_len;
}

char *cut_line_tail_crlf(char *string)
{
	if (strlen(string)) {
		if (string[strlen(string)-1] == '\n')
			string[strlen(string)-1] = '\0';
	}
	if (strlen(string)) {
		if (string[strlen(string)-1] == '\r')
			string[strlen(string)-1] = '\0';
	}
	return string;
}

int next_word(const char *string)
{
	const char *ptr;

	ptr = string;
	ptr += word_len(ptr);
	ptr += space_len(ptr);
	return ptr - string;
}
int word_len(const char *string)
{
	const char *ptr;

	ptr = string;
	if (*ptr)	// if not NULL, skip one byte even though space(' ').
		ptr++;
	for ( ; *ptr; ptr++) {
		if (*ptr == ' ')
			break;
	}
	return ptr - string;
}
const char *skip_space(const char *ptr)
{
	return ptr + space_len(ptr);
}
int space_len(const char *string)
{
	const char *ptr;

	for (ptr = string; *ptr; ptr++) {
		if (*ptr != ' ')
			break;
	}
	return ptr - string;
}
int utf8s_chars(const char *string, int bytes)
{
	int chars = 0;
	int idx;
	int len;

	for (idx = 0; string[idx] && idx < bytes; ) {
		len = utf8c_bytes(&string[idx]);
		idx += len;
		chars++;
	}
	return chars;
}
int tranc_utf8s_columns(char *string, int columns)
{
	int cols;
	char *str;

	for (str = string, cols = 0; *string; ) {
		cols += utf8c_columns(str);
		if (cols >= columns)
			break;
		str += utf8c_bytes(str);
	}
	*str = '\0';
	return str - string;
}
int utf8s_len_le(const char *string, int prev_len)
{
	int utf8_len;
	int len;

	for (utf8_len = 0; *string && utf8_len < prev_len; ) {
		len = utf8c_bytes(string);
//flf_d_printf("mblen(%s): %d\n", string, len);
		if (utf8_len + len > prev_len)
			break;
		string += len;
		utf8_len += len;
	}
	return utf8_len;
}
int utf8s_len_ge(const char *string, int prev_len)
{
	int utf8_len;
	int len;

	for (utf8_len = 0; *string && utf8_len < prev_len; ) {
		len = utf8c_bytes(string);
//flf_d_printf("mblen(%s): %d\n", string, len);
		string += len;
		utf8_len += len;
	}
	return utf8_len;
}

int utf8s_columns(const char *utf8s, int bytes)
{
	const char *ptr;
	int columns;

	for (ptr = utf8s, columns = 0; *ptr && ptr - utf8s < bytes; ) {
		columns += utf8c_columns(ptr);
		ptr += utf8c_bytes(ptr);
	}
	return columns;
}

PRIVATE int my_wcwidth(wchar_t wc);
int utf8c_columns(const char *utf8c)
{
	wchar_t wc;
	int columns;

	if (mbtowc(&wc, utf8c, 3) == 0)
		wc = 0;
//flf_d_printf("mbtowc(%s)==>%04x\n", utf8c, (int)wc);
///	mbtowc(&wc, utf8c, MB_CUR_MAX);
///	mbtowc(&wc, utf8c, UTF8_MAX_BYTES);
	columns = my_wcwidth(wc);
//flf_d_printf("wcwidth(%04x)==>%d\n", (int)wc, columns);
	return columns;
}
PRIVATE int my_wcwidth(wchar_t wc)
{
	int columns;

	columns = wcwidth(wc);
	if (columns < 1)
		columns = 1;
	return columns;
}

// UTF8 character byte length
int utf8c_bytes(const char *string)
{
#if 0
	return mblen(ptr1, MB_CUR_MAX);
#else
#define	IS_UTF8_2ND_BYTE(byte)		(((byte) & 0xc0) == 0x80)
	if ((*string & 0x80) == 0x00) {		// 0xxxxxxx
		if (string[0])
			return 1;
		return 0;
	} else
	if ((*string & 0xe0) == 0xc0) {		// 110xxxxx-10xxxxxx
		if (IS_UTF8_2ND_BYTE(string[1]))
			return 2;
	} else
	if ((*string & 0xf0) == 0xe0) {		// 1110xxxx-10xxxxxx-10xxxxxx
		if (IS_UTF8_2ND_BYTE(string[1])
		 && IS_UTF8_2ND_BYTE(string[2]))
			return 3;
	} else
	if ((*string & 0xf8) == 0xf0) {		// 11110xxx-10xxxxxx-10xxxxxx-10xxxxxx
		if (IS_UTF8_2ND_BYTE(string[1])
		 && IS_UTF8_2ND_BYTE(string[2])
		 && IS_UTF8_2ND_BYTE(string[3]))
			return 4;
	}
	return 1;
#endif
}

char *utf8strlcat(char *buf, int buf_len, const char *str)
{
	int len;

	len = strlen(str);
	return utf8strlncat(buf, buf_len, str, len);
}
char *strlcat(char *buf, const char *str, int buf_len)
{
	int len;

	len = strlen(str);
	return strlncat(buf, buf_len, str, len);
}

char *utf8strlncat(char *buf, int buf_len, const char *str, int len)
{
	int prev_len;

	prev_len = strlen(buf);
//flf_d_printf("strlncat([%s], %d, [%s], %d) prev_len:%d\n",
// buf, buf_len, str, len, prev_len);
	if (prev_len + len > buf_len) {
		len = buf_len - prev_len;
	}
	if (len > 0) {
		len = utf8s_len_le(str, len);
		strlcpy(&buf[prev_len], str, len);
	}
	return buf;
}
char *strlncat(char *buf, int buf_len, const char *str, int len)
{
	int prev_len;

	prev_len = strlen(buf);
//flf_d_printf("strlncat([%s], %d, [%s], %d) prev_len:%d\n",
// buf, buf_len, str, len, prev_len);
	if (prev_len + len > buf_len) {
		len = buf_len - prev_len;
	}
	if (len > 0) {
		strlcpy(&buf[prev_len], str, len);
	}
	return buf;
}

char *utf8strlncpy(char *buf, int buf_len, const char *str, int len)
{
	if (len > buf_len)
		len = buf_len;
	len = utf8s_len_le(str, len);
	return strlcpy(buf, str, len);
}
char *strlncpy(char *buf, int buf_len, const char *str, int len)
{
	if (len > buf_len)
		len = buf_len;
	return strlcpy(buf, str, len);
}
char *utf8strlcpy(char *buf, int buf_len, const char *str)
{
	return strlcpy(buf, str, utf8s_len_le(str, buf_len));
}
char *strlcpy(char *buf, const char *str, int len)
{
	strncpy(buf, str, len);
	buf[len] = '\0';	// make sure of null termination
	return buf;
}
///char *strnncpy(char *buf, const char *str, int len)
//{
//	strncpy(buf, str, len);
//	buf[len] = '\0';	// always null terminate
//	return buf;
//}
int strlcmp(const char *str1, const char *str2)
{
	return strncmp(str1, str2, strlen(str2));
}

///int __min(int aa, int bb)
///{
///	return __MIN(aa, bb);
///}
///int __max(int aa, int bb)
///{
///	return __MAX(aa, bb);
///}
///int __min_max(int min, int val, int max)
///{
///	return __MIN_MAX(min, val, max);
///}

static void (*debug_printf_callback)(const char *format, va_list args) = 0;
void set_debug_printf_callback(void (*callback)(const char *format, va_list args))
{
	debug_printf_callback = callback;
}
void _debug_printf(const char *format, ...)
{
	va_list args;

	va_start(args, format);
	if (debug_printf_callback == NULL) {
		vfprintf(stderr, format, args);
	} else {
		(*debug_printf_callback)(format, args);
	}
	va_end(args);
}

// End of imj.cpp
